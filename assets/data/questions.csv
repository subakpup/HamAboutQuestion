title,type,select1,select2,select3,select4,answer,img,level,date,recommenddate,update,description,solveddate,tag
"스프링 AOP에서 메소드 실행 이후 시점에 동작하는 Advice 유형은 크게 세 가지가 있습니다.  @After, @AfterReturning, @AfterThrowing  이 세 가지 Advice 애노테이션이 실행되는 조건(시점)과 주요 특징(차이점)을  ""예외 발생 여부"" 및 ""반환 값 접근"" 키워드를 중심으로 비교하여 서술하시오.",주관식,,,,,"@After (Finally):
  실행 조건: 대상 메소드의 실행이 예외를 발생시키는지 여부와 관계없이 항상 실행됩니다. (try-catch-finally 구문의 finally 블록과 유사합니다.)
  특징: 메소드가 정상 종료되었는지, 예외로 종료되었는지 알 수 없으며, 대상 메소드의 반환 값에 접근할 수 없습니다.

@AfterReturning (Success):
  실행 조건: 대상 메소드가 예외 없이 정상적으로 실행되어 반환(return)되었을 때만 실행됩니다.
  특징: returning 속성을 통해 대상 메소드의 반환 값에 접근하여 참조하거나 추가 로직을 수행할 수 있습니다. 예외가 발생하면 이 Advice는 실행되지 않습니다.

@AfterThrowing (Failure):
  실행 조건: 대상 메소드 실행 중 예외가 발생했을 때만 실행됩니다.
  특징: throwing 속성을 통해 발생한 예외 객체에 접근할 수 있습니다. 대상 메소드가 정상 종료되면 이 Advice는 실행되지 않습니다.",,0,2025-11-10,2025-11-10,2025-11-10,,,#AOP
"스프링 AOP에서 execution 지시자를 사용하여 Pointcut을 정의할 때, 다음 표현식이 의미하는 바를 서술하시오.",주관식,,,,,이 Pointcut 표현식은 com.example.service 패키지 및 그 **모든 하위 패키지( .. )**에 속한 **모든 타입(클래스/인터페이스)**의 **모든 메소드( * )**를 대상으로 합니다.,/images/id-sl83wy47m.png,0,2025-11-10,2025-11-10,2025-11-10,"차례대로 

- *: 모든 반환 타입을 의미합니다.

- com.example.service..: com.example.service 패키지와 그 모든 하위 패키지를 의미합니다.

- *: 패키지 내의 모든 클래스/인터페이스 이름을 의미합니다.

- *(..): 모든 이름의 메소드를 의미하며, (..)는 0개 이상의 모든 파라미터 타입을 의미합니다. (즉, com.example.service 패키지 및 하위 패키지의 모든 메소드 실행에 Advice를 적용하겠다는 의미입니다.)",,#AOP
"AOP의 Advice 유형 중, 대상 메소드의 실행을 직접 제어할 수 있으며(예: 실행 중단, 반환 값 변경), 메소드 실행 전후로 로직을 수행할 수 있는 가장 강력한 Advice 유형은 무엇인가?",객관식,@Before,@AfterReturning,@AfterThrowing,@Around,@Around,,0,2025-11-10,2025-11-10,2025-11-10,"@Around Advice는 ProceedingJoinPoint 객체를 매개변수로 받아, proceed() 메소드를 통해 대상 메소드의 실행 시점을 직접 제어할 수 있습니다. proceed() 호출 전후로 로직을 추가할 수 있으며, proceed()를 호출하지 않으면 대상 메소드가 실행되지 않게 하거나, 반환 값을 가로채 변경하는 것도 가능합니다. 반면 @Before, @AfterReturning, @AfterThrowing은 대상 메소드의 실행 전, 성공적 반환 후, 예외 발생 시에만 동작하며 실행 자체를 제어하지는 못합니다.",,#AOP
다음 중 스프링 AOP의 핵심 용어에 대한 설명으로 가장 옳지 않은 것은?,객관식,"Aspect: 공통 관심 사항(Cross-cutting concern)을 모듈화한 단위로, 여러 개의 Advice와 Pointcut의 조합으로 구성된다.","Join Point: Advice가 적용될 수 있는 애플리케이션 실행의 모든 지점(예: 메소드 호출, 필드 접근)을 의미한다.",Pointcut: 수많은 Join Point 중에서 Advice가 실제로 적용될 지점을 선별하기 위한 정규 표현식 또는 조건식이다.,"Weaving: Pointcut에 의해 선별된 Join Point에 Advice 로직을 삽입하는 과정으로, 스프링은 주로 컴파일 시점에 이를 수행한다.","Weaving: Pointcut에 의해 선별된 Join Point에 Advice 로직을 삽입하는 과정으로, 스프링은 주로 컴파일 시점에 이를 수행한다.",,0,2025-11-10,2025-11-10,2025-11-10,"Weaving에 대한 설명에서 스프링 AOP는 AspectJ와 달리 컴파일 시점(CTW)이나 로드 시점(LTW)이 아닌, **런타임 시점(Runtime)**에 프록시 객체를 생성하여 Advice를 적용하는 방식(Runtime Weaving)을 기본 전략으로 사용합니다.",,#AOP
현대적인 스프링 부트 애플리케이션 개발에서는 객체의 불변성(Immutability) 확보를 위해 생성자 주입 방식을 권장한다. Lombok 라이브러리를 사용하여 final로 선언된 필수 필드에 대한 생성자를 자동으로 생성하고자 할 때 가장 적절한 어노테이션은?,객관식,@NoArgsConstructor,@AllArgsConstructor,@RequiredArgsConstructor,@Data,@RequiredArgsConstructor,,0,2025-11-10,2025-11-10,2025-11-10,해설: @RequiredArgsConstructor는 초기화되지 않은 final 필드나 @NonNull이 붙은 필드만을 파라미터로 받는 생성자를 자동으로 생성합니다. 이는 불필요한 필드까지 포함하는 @AllArgsConstructor보다 생성자 주입 패턴에 더욱 최적화되어 있습니다.,,
"스프링 프레임워크는 계층별 역할 명시를 위해 @Component의 특수화된 형태(Stereotype)를 제공한다. 다음 중 이러한 계층별 빈 등록을 위한 어노테이션이 아니라, 등록된 빈을 '주입'받기 위한 메커니즘에 해당하는 것은?",객관식,@Service,@Repository,@Autowired,@Controller,@Autowired,,0,2025-11-10,2025-11-10,2025-11-10,"해설: @Service(비즈니스 계층), @Repository(영속 계층), @Controller(프레젠테이션 계층)는 모두 컴포넌트 스캔의 대상이 되어 자동으로 빈으로 '등록'되는 역할을 합니다. 반면, @Autowired는 컨테이너에 이미 등록된 빈을 필요한 곳에 '주입'하는 역할을 수행합니다.",,
동일한 인터페이스를 구현한 빈(Bean)이 두 개 이상 등록되어 있어 @Autowired 만으로는 주입 대상이 모호한 상황이 발생했다. 이때 특정 빈을 명시적으로 지정하여 모호성을 해결하기 위해 병행하여 사용해야 할 어노테이션은?,객관식,@Qualifier,@Component,@Service,@Controller,@Qualifier,,0,2025-11-10,2025-11-10,2025-11-10,"해설: 의존성 주입 대상이 여러 개일 경우 스프링 컨테이너는 어떤 빈을 주입해야 할지 판단할 수 없어 오류가 발생합니다. 이때 @Qualifier(""빈이름"")을 함께 사용하여 주입할 빈을 구체적으로 한정지을 수 있습니다.",,
"자바 표준(JSR-250) 스펙을 따르며, 의존성 주입(DI) 시 타입(Type)이 아닌 빈의 '이름(Name)'을 우선적인 주입 기준으로 삼는 어노테이션은 무엇인가?",객관식,@Autowired,@Inject,@Resource,@RequiredArgsConstructor,@Resource,,0,2025-11-10,2025-11-10,2025-11-10,"해설: @Resource는 자바 표준 어노테이션으로, name 속성을 사용하여 특정 빈 이름으로 의존성을 주입받을 때 주로 사용됩니다. 반면 @Autowired(스프링 전용)와 @Inject(자바 표준)는 기본적으로 타입(Type)을 기준으로 주입 대상을 찾습니다.",,
"다수의 필드를 가진 복잡한 객체(예: Address 클래스)를 설계할 때, 전통적인 전체 인자 생성자(All-args constructor) 대신 빌더(Builder) 패턴을 도입함으로써 얻을 수 있는 가장 주된 소프트웨어 공학적 이점은 무엇인가?",객관식,컴파일 시점에 객체 생성 속도가 현저히 향상된다.,"인자의 순서에 구애받지 않으며, 코드의 가독성과 유지보수성이 증대된다.",객체 생성 시 모든 필드를 강제로 초기화하도록 제한할 수 있다.,별도의 라이브러리 의존성 없이 자바 언어 자체 기능만으로 구현이 가능하다.,"인자의 순서에 구애받지 않으며, 코드의 가독성과 유지보수성이 증대된다.",,0,2025-11-10,2025-11-10,2025-11-10,"해설: 빌더 패턴은 메서드 체이닝을 통해 각 필드를 명시적으로 지정할 수 있게 해줍니다. 이는 생성자 인자가 많을 때 발생할 수 있는 인자 순서 혼동을 방지하고, 클라이언트 코드의 가독성을 크게 높여 유지보수를 용이하게 합니다.",,
"application.properties 파일이 아래와 같고, SystemInfo 빈이 로드되었을 때, info.getDetails()의 출력 결과로 올바른 것은?",객관식,${system.name} | ${system.admin:admin} | v9.0,SSAFY | admin | v9.0,SSAFY | admin | v${version},SSAFY | null | v9.0,SSAFY | admin | v9.0,/images/id-ocd3ohj9b.png,0,2025-11-10,2025-11-10,2025-11-10,"1. ${...} : system.name은 프로퍼티 파일에서 ""SSAFY"" 값을 찾아 name 필드에 주입합니다.

2. ""..."" (리터럴): version 필드는 ${...} 구문이 없으므로 ""9.0"" 문자열 리터럴 자체가 주입됩니다.

3. ${... : default} : system.admin 프로퍼티는 파일에 존재하지 않습니다. 이때 콜론(:) 뒤에 정의된 ""admin""이 기본값으로 admin 필드에 주입됩니다. 따라서 getDetails()는 ""SSAFY | admin | v9.0""을 반환합니다.",,"@Value,프로퍼티 주입"
"스프링 빈(Bean)의 생명주기(Lifecycle)에서, 생성자 호출과 모든 의존성 주입이 완료된 **'직후'**에 특정 초기화 로직(예: 자원 연결, 캐시 예열)을 실행하고 싶을 때 사용하는 애너테이션은 무엇인가요?",객관식,@PostConstruct,@PreDestroy,"@Bean(initMethod = ""..."")",@Autowired,@PostConstruct,,0,2025-11-10,2025-11-10,2025-11-10,,,빈 생명주기
"여러분이 소스 코드를 수정할 수 없는 외부 라이브러리의 클래스(예: ExternalImageProcessor)를 스프링 빈으로 등록해야 할 때, 가장 적절한 DI 방식은 무엇인가요?",객관식,묵시적 DI: 해당 라이브러리 클래스에 직접 @Component를 추가한다.,"명시적 DI: @Configuration 클래스 내부에 @Bean 메서드를 만들고, 그 안에서 new ExternalImageProcessor()를 반환한다.",필드 주입: 사용할 클래스에서 @Autowired로 ExternalImageProcessor를 바로 주입받는다.,Setter 주입: @ComponentScan으로 해당 라이브러리를 스캔한다.,"명시적 DI: @Configuration 클래스 내부에 @Bean 메서드를 만들고, 그 안에서 new ExternalImageProcessor()를 반환한다.",,0,2025-11-10,2025-11-10,2025-11-10,"2번 해설: 묵시적 DI(@Component)는 우리가 소스 코드를 수정할 수 있을 때만 사용할 수 있습니다. 외부 라이브러리의 코드는 수정이 불가능하므로 @Component를 붙일 수 없습니다. 이때 명시적 DI를 사용합니다. 우리의 @Configuration 설정 파일에 @Bean이 붙은 메서드를 만들고, 그 메서드 내부에서 new ExternalImageProcessor()를 호출하여 객체를 생성한 뒤 반환하면, 스프링 컨테이너가 이 객체를 빈으로 관리해 줍니다.",,"명시적 DI,#외부 라이브러리,@Bean"
" 묵시적 DI 방식에서 '@Component' 애너테이션의 주된 역할로 올바른 것은 무엇인가요?",객관식,명시적 DI에서 '@Bean'을 대체하여 설정 클래스에 사용된다.,"'@ComponentScan'이 스캔할 빈 대상을 표시하며, 스테레오타입 애너테이션의 기본이 된다.",오직 '@Service'나 '@Repository' 내부에서만 사용 가능하다.,이 애너테이션을 붙이면 즉시 싱글턴 빈(Bean)이 생성된다.,"'@ComponentScan'이 스캔할 빈 대상을 표시하며, 스테레오타입 애너테이션의 기본이 된다.",,0,2025-11-10,2025-11-10,2025-11-10,"@Component는 ""이 클래스는 빈이 될 수 있다""는 의도만 나타낼 뿐, 실제로 빈을 만들지는 않습니다. **@ComponentScan**이 이 애너테이션이 붙은 클래스들을 스캔해야 비로소 빈으로 등록됩니다. 또한 @Service, @Repository 등 다른 모든 스테레오타입 애너테이션의 내부에 포함되는 기본 애너테이션입니다.",,묵시적 DI
Spring에서 필드 주입(@Autowired 필드에 직접 사용)보다 생성자 주입을 권장하는 이유로 가장 적절한 것은 무엇인가요?,객관식,코드가 더 간결해지고 시각적으로 보기 좋기 때문이다.,필드 주입은 'private' 필드에는 사용할 수 없기 때문이다.,"final 키워드를 사용하여 의존성의 '불변성'을 보장하고, 테스트 코드 작성이 용이하기 때문이다.",생성자 주입만이 유일하게 순환 참조(Circular Dependency)를 해결할 수 있기 때문이다.,"final 키워드를 사용하여 의존성의 '불변성'을 보장하고, 테스트 코드 작성이 용이하기 때문이다.",,0,2025-11-10,2025-11-10,2025-11-10,"생성자 주입의 가장 큰 장점은, 주입받는 필드를 final로 선언하여 불변성을 확보할 수 있다는 점입니다. 또한, 순수 Java로 테스트 코드를 작성할 때 Mock 객체를 주입하기 매우 용이합니다.


1번은 오히려 필드 주입이 더 간결해 보입니다.

2번은 틀렸습니다. 필드 주입도 private 필드에 잘 동작합니다.

4번은 틀렸습니다. 생성자 주입은 순환 참조를 '해결'하는 것이 아니라, 빈 생성 시점에 오류를 발생시켜 즉시 발견하게 해줍니다.",,DI 주입 방식
Given-When-Then 패턴에서 각각이 무엇을 뜻하는지 쓰시오,주관식,,,,,"Given : 테스트를 위한 필요한 상황 준비
When : 테스트 하는 메서드 실행
Then : 테스트 결과 검증 ",,0,2025-11-10,2025-11-10,2025-11-10,,,Junit
테스트 원칙에 대한 설명으로 옳지 않은 것은?,객관식,여러번 반복해서 테스트를 진행하더라도 동일하게 동작해야 한다,@SpringBootTest는 슬라이스 테스트로 단위 테스트에 사용하기 적합하다,어떤 순서로 테스트를 하더라도 언제나 테스트는 성공해야 한다,테스트 자체 만으로 검증이 완료되어야 한다,@SpringBootTest는 슬라이스 테스트로 단위 테스트에 사용하기 적합하다,,0,2025-11-10,2025-11-10,2025-11-10,,,JUnit
다음 코드 실행 결과로 콘솔에 출력되는 로그 레벨을 쓰시오,주관식,,,,,"INFO,WARN,ERROR",/images/id-1qn73txa2.png,0,2025-11-10,2025-11-10,2025-11-10,,,Logging
JUnit 테스트 코드에 대한 설명으로 틀린 것은?,객관식,@BeforeEach 는 각 테스트 실행 전마다 실행된다,@AfterAll은 클래스 내 모든 테스트가 끝난 뒤 한 번 실행된다,assertThrows()는 특정 메서드가 예외를 던지는지 검사한다,"assertEquals() 첫번째 인자는 실제값, 두번째 인자는 기대값이다 ","assertEquals() 첫번째 인자는 실제값, 두번째 인자는 기대값이다 ",,0,2025-11-10,2025-11-10,2025-11-10,,,JUnit
다음 중 Logback의 logback.xml 설정에 대한 설명으로 옳지 않은 것은?,객관식,<appender>는 로그를 어디로 보낼지 정의한다,<encoder>는 로그 메세지의 형식을 지정한다,"<root level=""INFO"">는 INFO이하의 로그를 모두 출력한다",<rollingPolicy>는 롤링 정책을 지정한다,"<root level=""INFO"">는 INFO이하의 로그를 모두 출력한다",,0,2025-11-10,2025-11-10,2025-11-10,,,Logging