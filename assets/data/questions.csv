title,type,select1,select2,select3,select4,answer,img,level,date,recommenddate,update,description,solveddate,tag
Spring AOP의 Proxy 동작 원리에 대한 설명으로 틀린 것은?,객관식,Spring은 Proxy 기반의 AOP를 사용한다,대리인인 Proxy가 target 메서드를 직접 호출한다,Spring Container가 Bean 생성 시 자동으로 Proxy 객체를 생성한다,@Autowired로 주입받으면 원본 target 객체가 주입된다,@Autowired로 주입받으면 원본 target 객체가 주입된다,,0,2025-11-21,2025-11-21,2025-11-21,"@Autowired로 주입받으면 Proxy 객체가 주입됨
실제 주입되는 것: BasicMemberDao$$SpringCGLIB$$... 같은 Proxy
Proxy가 부가 기능(Advice) 실행 후 → 실제 target 호출",,aod
다음 코드의 실행 결과로 옳은 것은?,객관식,1 Before → After → 실제 메서드 실행,2. 실제 메서드 실행 → 1Before →After,Before → 실제 메서드 실행 → After,컴파일 에러 발생,Before → 실제 메서드 실행 → After,/images/id-pjmzz0nyl.png,0,2025-11-21,2025-11-21,2025-11-21,"- @Around는 `pjp.proceed()`를 호출하는 시점에 실제 메서드가 실행됨
- proceed() 전후로 코드 실행 가능",,aod
메서드가 예외를 던질 때만 동작하여 에러 로그를 기록하고 싶습니다. 가장 적합한 Advice 타입은?,객관식," @Before - target 메서드 실행 전에 advice 실행"," @After - 예외 상관없이 finally와 같이 항상 실행",@AfterReturning - 정상적으로 종료된 경우만 실행,@AfterThrowing - 예외가 던져진 경우만 실행,@AfterThrowing - 예외가 던져진 경우만 실행,,0,2025-11-21,2025-11-21,2025-11-21,"@AfterThrowing
target이 던진 예외를 자동 받을 수 있음
예외가 발생한 경우에만 advice가 실행됨",,aod
다음 중 Pointcut 지정자에 대한 설명이 옳은 것은?,객관식,execution: 특정 클래스 타입을 기준으로 pointcut을 작성,"within: 메서드의 signature를 기준으로 pointcut을 작성  ",bean: 빈의 이름을 기준으로 pointcut을 작성," annotation: Join Point에서 Advice를 호출할 것인지 결정",bean: 빈의 이름을 기준으로 pointcut을 작성,,0,2025-11-21,2025-11-21,2025-11-21,"① execution: 메서드의 signature 기준 (반환타입, 패키지, 클래스, 메서드명, 파라미터)
② within: 특정 클래스나 패키지 타입을 기준
③ bean: 빈의 이름으로 pointcut 작성 (정답)
④ annotation: 특정 annotation이 선언된 메서드를 pointcut으로 작성",,aod
다음 중 AOP 용어에 대한 설명이 틀린 것은?,객관식,target: AOP가 적용되는 대상 객체,aspect: 모듈화된 부가 기능 (하나 이상의 advice로 구성),advice: 부가 기능 코드가 실행되는 시점을 결정하는 메서드,pointcut: advice가 적용될 대상을 결정하는 메서드,advice: 부가 기능 코드가 실행되는 시점을 결정하는 메서드,,0,2025-11-21,2025-11-21,2025-11-21,"advice는 부가 기능 코드를 모듈화한 메서드이며, annotation을 통해 상황별 동작 순서가 구분됨
실행 시점을 결정하는 것은 @Before, @After 같은 annotation

",,AOP
다음 중 @AfterReturning Advice의 특징으로 맞는 것은?,객관식,예외가 발생한 경우에도 무조건 실행된다.,정상적으로 return된 경우에만 동작하며 return 값을 조작할 수 있다.,메서드 수행 전 동작하며 인자 값을 변경할 수 있다.,예외가 발생했을 때만 실행되며 try-catch로 예외를 처리한다.,정상적으로 return된 경우에만 동작하며 return 값을 조작할 수 있다.,,0,2025-11-21,2025-11-21,2025-11-21,"- 정상적으로 종료(return)된 경우 동작
- 반환받은 return 값 조작 가능",,AOP
다음 중 특정 Bean 이름을 기준으로 Pointcut을 설정하는 지정자는?,객관식,within,execution,annotation,bean,bean,,0,2025-11-21,2025-11-21,2025-11-21,"bean(""beanName"") 형태로 특정 빈에만 적용 가능",,AOP
"아래 예제 코드를 보고, execution 지정자의 올바른 return 타입을 고르시오.",객관식,void,와일드카드(*),public void,public *,와일드카드(*),/images/id-5itxazcqu.png,0,2025-11-21,2025-11-21,2025-11-21,"return_type(필수), 와일드카드(*) 사용 가능

즉, 어떤 반환 타입이든 허용하려면 * 사용.

“public void” 형태는 접근 제어자+타입까지 지정하는 경우인데 주어진 문맥에서는 필요 없음.",,AOP
다음 코드의 빈칸에 들어갈 Pointcut 지정자로 알맞은 것은?,객관식,execution,bean,annotation,within,within,/images/id-bfomx2r9d.png,0,2025-11-21,2025-11-21,2025-11-21,"within: “특정 패키지/타입을 기준으로 poincut 작성 가능”

within(com.ssafy.dao..*) 는 DAO 패키지 전체 클래스를 대상으로 한다.

execution은 “메서드 시그니처 기반 필터링”이라서 (com.ssafy.dao..*) 형태로 사용되지 않는다.",,AOP
다음 중 Advice 타입과 동작 시점이 올바르게 매칭된 것은?,객관식,@Before ― 메서드 실행 후 정상 종료 시 실행,@AfterThrowing ― 메서드가 정상 종료된 후 실행,@AfterReturning ― 메서드가 정상적으로 return된 경우 실행,@Around ― 메서드가 예외를 던질 때만 실행,@AfterReturning ― 메서드가 정상적으로 return된 경우 실행,,0,2025-11-21,2025-11-21,2025-11-21,,,AOP
다음 중 AOP에서 Join Point에 대한 설명으로 옳은 것은?,객관식,AOP에서 공통 기능(Aspect)을 실제로 적용하기 위해 사용하는 표현식이다.,"AOP가 적용될 수 있는 지점을 의미하며, 스프링에서는 메서드 실행 시점으로 제한된다.","공통 기능을 모아놓은 모듈이며, Advice와 Pointcut을 포함한다.",비즈니스 로직을 수행하는 핵심 메서드를 의미한다.,"AOP가 적용될 수 있는 지점을 의미하며, 스프링에서는 메서드 실행 시점으로 제한된다.",,0,2025-11-21,2025-11-21,2025-11-21,,,AOP
"Spring 웹 애플리케이션의 요청 처리 과정에서 Filter와 Interceptor의 실행 시점에 대한 설명으로 가장 올바른 것은? ",객관식,Filter와 Interceptor는 모두 DispatcherServlet 이전에 실행된다.,"Filter는 DispatcherServlet 이전에 실행되고, Interceptor는 DispatcherServlet 이후에 실행된다.",Filter와 Interceptor는 모두 DispatcherServlet 이후에 실행된다.,"Interceptor는 DispatcherServlet 이전에 실행되고, Filter는 그 이후에 실행된다.","Filter는 DispatcherServlet 이전에 실행되고, Interceptor는 DispatcherServlet 이후에 실행된다.",,0,2025-11-21,2025-11-21,2025-11-21,"Filter는 웹 컨테이너(Tomcat 등) 영역에 속해 가장 먼저 실행되며, 그 후 DispatcherServlet이 실행되고, 그 내부인 Spring Context 영역에서 Interceptor가 실행됩니다.",,#인터셉터 #필터
"HandlerInterceptor 인터페이스의 메서드 중, '뷰(View) 렌더링까지 모두 완료된 후'에 호출되는 메서드는?",객관식,preHandle(),postHandle(),afterCompletion(),doFilter(),afterCompletion(),,0,2025-11-21,2025-11-21,2025-11-21,"해설: preHandle(컨트롤러 전), postHandle(컨트롤러 후, 뷰 렌더링 전), afterCompletion(모든 작업 완료 후) 순으로 실행됩니다.",,#인터셉터
다음 중 Interceptor보다 Filter를 사용하는 것이 더 적절한 기능은?,객관식,특정 사용자의 권한(Authorization) 체크 및 비즈니스 로직 검사,API 요청에 대한 호출된 컨트롤러 메서드 정보를 포함한 상세정보 로깅,HTTP 요청 본문(Body) 데이터 인코딩 변환 또는 XSS 방어,컨트롤러 실행 후 모델(Model) 데이터 가공,HTTP 요청 본문(Body) 데이터 인코딩 변환 또는 XSS 방어,,0,2025-11-21,2025-11-21,2025-11-21,해설: 인코딩 변환이나 XSS 방어처럼 스프링 빈과 무관하게 데이터 자체를 조작하거나 가장 앞단에서 막아야 하는 보안 처리는 Filter가 적합합니다.,,
Filter 인터페이스의 default 메서드를 포함한 모든 메서드 중 필터 객체가 생성될 때 초기화 작업을 위해 한 번만 호출되는 메서드는?,객관식,start(),initialize(),setup(),init(),init(),,0,2025-11-21,2025-11-21,2025-11-21,Filter 인터페이스의 init(FilterConfig filterConfig) 메서드는 서블릿 컨테이너가 필터를 인스턴스화한 후 초기화를 위해 딱 한 번 호출합니다. (반대로 종료 시에는 destroy()가 호출됩니다.),,#인터셉터
HandlerInterceptor의 afterCompletion 메서드의 주요 용도 및 특징으로 올바른 것은?,객관식,사용자의 로그인 세션을 검증하여 컨트롤러 접근을 막는다.,뷰(View)에 전달할 모델 데이터를 추가하거나 수정한다.,"요청 처리 도중 사용된 리소스(파일 핸들, 스레드 로컬 등)를 정리(Clean-up)한다.",HTTP 요청의 바디 내용을 파싱하여 로깅한다.,"요청 처리 도중 사용된 리소스(파일 핸들, 스레드 로컬 등)를 정리(Clean-up)한다.",,0,2025-11-21,2025-11-21,2025-11-21,"afterCompletion은 뷰 렌더링까지 모든 작업이 완료된 후에, 예외가 발생하더라도 실행됩니다. 따라서 주로 스레드 로컬(ThreadLocal) 정리나 리소스 해제와 같은 마무리 작업에 사용됩니다. 컨트롤러 접근을 막는 건 postHandle, View에 전달할 모델 데이터를 추가/수정하거나 HTTP 요청의 body 내용을 파싱하는 건 postHandle이 적절합니다.",,#인터셉터
HandlerInterceptor의 postHandle 메서드에 대한 설명으로 옳은 것은?,객관식,"컨트롤러 실행 전, 뷰(View)가 렌더링되기 전에 실행된다.","컨트롤러가 실행되고 난 후, 뷰(View)가 렌더링된 후에 실행된다.③ 컨트롤러 실행 여부와 관계없이 항상 마지막에 실행된다.",컨트롤러 실행 여부와 관계없이 항상 마지막에 실행된다.,컨트롤러에서 예외가 발생하더라도 무조건 실행된다.,"컨트롤러 실행 전, 뷰(View)가 렌더링되기 전에 실행된다.",,0,2025-11-21,2025-11-21,2025-11-21,"postHandle은 컨트롤러(핸들러)가 정상적으로 실행된 후, View가 렌더링되기 전에 실행됩니다. 따라서 ModelAndView 객체를 조작하여 뷰에 전달할 데이터를 추가할 수 있습니다. 컨트롤러에서 예외가 발생하면 postHandle은 실행되지 않습니다.",,#인터셉터
Filter 인터페이스의 doFilter 메서드에서 다음 필터나 서블릿으로 요청을 전달하기 위해 반드시 호출해야 하는 코드는?,객관식,"request.getRequestDispatcher(path).forward(request, response);",response.sendRedirect(url);,"chain.doFilter(request, response);",return true;,"chain.doFilter(request, response);",,0,2025-11-21,2025-11-21,2025-11-21,"FilterChain의 doFilter(request, response)를 호출해야만 다음 필터 체인을 타거나, 필터가 끝났다면 서블릿(DispatcherServlet)으로 요청이 넘어갑니다. 이를 호출하지 않으면 요청 처리가 거기서 중단됩니다.",,#필터
"HandlerInterceptor 인터페이스의 메서드 중, 컨트롤러(핸들러)가 실행되기 직전에 호출되는 메서드는?",객관식,doFilter(),preHandle(),postHandle(),afterCompletion(),preHandle(),,0,2025-11-21,2025-11-21,2025-11-21,preHandle()은 컨트롤러 호출 전에 실행됩니다. 이 메서드가 false를 반환하면 이후의 인터셉터나 컨트롤러는 실행되지 않습니다.,,#인터셉터
필터(Filter)의 특징으로 올바른 것은?,객관식,스프링 빈(Bean)을 주입받을 수 없다.,DispatcherServlet이 실행된 이후에 동작한다.,Request와 Response 객체를 다른 객체로 교체(Wrapping)하여 전달할 수 있다.,HandlerMethod 파라미터를 통해 어떤 컨트롤러가 실행될지 알 수 있다.,Request와 Response 객체를 다른 객체로 교체(Wrapping)하여 전달할 수 있다.,,0,2025-11-21,2025-11-21,2025-11-21,정답 : 필터는 chain.doFilter()를 호출할 때 Request/Response 객체를 래핑(Wrapping)하여 다음 체인으로 전달할 수 있습니다(예: HttpServletRequestWrapper). 오답 1 : 스프링 부트에서는 필터도 빈으로 등록 가능하여 주입받을 수 있습니다. 오답 2: 필터는 DispatcherServlet 이전에 실행됩니다. 오답 3: HandlerMethod는 인터셉터에서 접근 가능합니다.,,#인터셉터 #필터
다음 중 인터셉터(Interceptor)가 처리하기에 가장 적절한 작업은?,객관식,요청 바디(Request Body)의 인코딩 변환,이미지/데이터 압축 및 해제,컨트롤러 도달 전에 특정 API 호출에 대한 회원 인증 및 권한 체크,전역적 공통된 보안 정책에 따른 CORS 헤더 설정,컨트롤러 도달 전에 특정 API 호출에 대한 회원 인증 및 권한 체크,,0,2025-11-21,2025-11-21,2025-11-21,"HttpServletRequest/Response의 raw level 데이터의 조작, 전역적인 설정에는 필터가 적합합니다. 반면 회원 인증/인가 등 비즈니스 로직과 밀접하거나 특정 핸들러 실행 여부를 결정하는 작업은 핸들러 정보를 알 수 있는 인터셉터가 적합합니다.",,#인터셉터 #필터
Spring Boot에서 인터셉터를 등록하기 위해 구현해야 하는 인터페이스는 무엇인가?,객관식,WebMvcConfigurer,FilterRegistrationBean,ServletContextListener,ApplicationContextAware,WebMvcConfigurer,,0,2025-11-21,2025-11-21,2025-11-21,인터셉터를 등록하려면 설정 클래스에서 WebMvcConfigurer 인터페이스를 구현하고 addInterceptors() 메서드를 오버라이딩하여 등록합니다.,,#인터셉터
필터(Filter)와 인터셉터(Interceptor)의 차이점에 대한 설명으로 옳지 않은 것은?,객관식,"필터는 서블릿 컨테이너(Web Container)에 의해 관리되고, 인터셉터는 스프링 컨테이너(Spring Container)에 의해 관리된다.",필터는 주로 인코딩이나 보안(XSS 방어) 등 전역적인 요청/응답 처리에 사용된다.,"인터셉터는 HttpServletRequest, HttpServletResponse 객체뿐만 아니라 실행될 컨트롤러(Handler) 정보에도 접근할 수 있다.","인터셉터에서 예외가 발생하면 web.xml의 에러 페이지 설정에 의해서만 처리 가능하며, @ControllerAdvice로는 처리할 수 없다.","인터셉터에서 예외가 발생하면 web.xml의 에러 페이지 설정에 의해서만 처리 가능하며, @ControllerAdvice로는 처리할 수 없다.",,0,2025-11-21,2025-11-21,2025-11-21,인터셉터는 스프링 컨텍스트 내부에 존재하므로 서블릿 예외 처리뿐만 아니라 스프링의 예외 처리 기능인 @ControllerAdvice 등을 활용하여 예외를 처리하기 훨씬 수월합니다.,,#필터 #인터셉터
Spring Boot 웹 애플리케이션의 요청 처리 흐름 순서로 올바른 것은?,객관식,Client → Filter → DispatcherServlet → Interceptor → Controller,Client → Interceptor → DispatcherServlet → Filter → Controller,Client → DispatcherServlet → Filter → Interceptor → Controller,Client → Filter → Interceptor → DispatcherServlet → Controller,Client → Filter → DispatcherServlet → Interceptor → Controller,,0,2025-11-21,2025-11-21,2025-11-21,"요청이 들어오면 가장 먼저 Web Context 영역에 있는 Filter를 거치게 됩니다. 이후 Spring 영역으로 들어와 DispatcherServlet이 요청을 받고, 핸들러 매핑을 통해 컨트롤러를 찾은 뒤 Interceptor를 거쳐 Controller에 도달합니다. (FilterRegistrationBean은 필터를 빈으로 등록할 때 사용됩니다.)",,#인터셉터 #필터
"Spring Web MVC의 핵심 디자인 패턴으로, 모든 클라이언트의 요청을 가장 먼저 받아 세부 컨트롤러나 컴포넌트로 작업을 위임하는 역할을 하는 것은?",객관식,ViewResolver,HandlerMapping,DispatcherServlet,HandlerAdapter,DispatcherServlet,,0,2025-11-21,2025-11-21,2025-11-21,"DispatcherServlet은 Front Controller 패턴의 구현체로, Spring MVC의 진입점이자 심장 역할을 합니다.",,Spring
Spring MVC의 동작 흐름 중 HandlerMapping의 역할로 올바른 것은?,객관식,논리적인 뷰 이름을 실제 물리적인 뷰 경로로 변환한다.,요청(URL)을 처리할 수 있는 적절한 핸들러(Controller)를 찾는다.,컨트롤러의 실행 결과를 화면에 출력한다.,HTTP 요청의 인코딩을 변환한다.,요청(URL)을 처리할 수 있는 적절한 핸들러(Controller)를 찾는다.,,0,2025-11-21,2025-11-21,2025-11-21,"HandlerMapping은 들어온 요청(URL, Method)을 누가(어떤 Controller 메서드) 처리할지 결정합니다. 뷰 변환은 ViewResolver의 역할입니다.",,Spring
"다음 중 Servlet Filter, Interceptor, AOP에 대한 설명으로 틀린 것은?",객관식,Servlet Filter: DispatcherServlet 호출 전에 실행된다.,Interceptor: Controller 사이에서 요청을 가로챈다.,AOP: 메서드 레벨의 정밀한 제어에 사용된다.,Interceptor: web.xml에 등록하며 Spring Bean을 사용할 수 없다.,Interceptor: web.xml에 등록하며 Spring Bean을 사용할 수 없다.,,0,2025-11-21,2025-11-21,2025-11-21,"Interceptor는 Spring Context 내부에서 동작하므로 Spring Bean(@Service, @Component 등)을 주입받아 사용하기 용이하며, Java Config(WebMvcConfigurer)를 통해 등록합니다.",,Spring
"HandlerInterceptor 인터페이스의 메서드 중, 뷰 렌더링까지 모두 완료된 후에 실행되며 주로 예외 로그나 리소스 정리에 사용되는 메서드는?",객관식,preHandle(),postHandle(),afterCompletion(),init(),afterCompletion(),,0,2025-11-21,2025-11-21,2025-11-21,"preHandle은 컨트롤러 실행 전, postHandle은 컨트롤러 실행 후(뷰 렌더링 전), afterCompletion은 뷰 렌더링까지 끝난 후에 실행됩니다.",,Spring
"Spring MVC 설정을 커스터마이징하기 위해 구현해야 하는 인터페이스로, addInterceptors 메서드 등을 포함하고 있는 것은?",객관식,WebMvcConfigurer,ApplicationContextAware,ServletContextListener,ControllerAdvice,WebMvcConfigurer,,0,2025-11-21,2025-11-21,2025-11-21,"WebMvcConfigurer 인터페이스를 구현하여 인터셉터 등록, CORS 설정, 뷰 컨트롤러 추가 등의 설정을 할 수 있습니다.",,Spring
DispatcherServlet은 개발자가 직접 모든 코드를 구현해야 하는 클래스이다. (O/X),객관식,O,X,,,X,,0,2025-11-21,2025-11-21,2025-11-21,"DispatcherServlet은 스프링 프레임워크에서 제공하는 클래스이며, 개발자는 주로 Controller, Service, Repository 등을 구현합니다.",,Spring
"Interceptor의 preHandle 메서드가 false를 반환하면, 다음 단계(컨트롤러 실행)로 진행하지 않고 요청 처리가 중단된다. (O/X)",객관식,O,X,,,O,,0,2025-11-21,2025-11-21,2025-11-21,preHandle의 반환값이 false이면 이후의 핸들러(컨트롤러)나 인터셉터가 실행되지 않고 요청 처리가 끝납니다. 주로 로그인 인증 체크 등에 활용됩니다.,,Spring
Spring MVC에서 Service와 Repository 영역은 개발자가 직접 작성해야 하는 영역이다. (O/X),객관식,O,X,,,O,,0,2025-11-21,2025-11-21,2025-11-21,스프링이 제공하는 인프라 빈(DispatcherServlet 등)과 달리 비즈니스 로직(Service)과 데이터 접근(Repository)은 개발자가 구현해야 합니다.,,Spring
"다음 상황에서 Console에 출력될 로그의 순서를 예측하시오. (Interceptor: preHandle='A', postHandle='B', afterCompletion='C' / Controller: 'D')",주관식,,,,,A -> D -> B -> C,,0,2025-11-21,2025-11-21,2025-11-21,실행 순서: preHandle(A) -> Controller(D) -> postHandle(B) -> View Rendering -> afterCompletion(C),,Spring
"클라이언트 요청 처리 순서를 올바르게 나열하시오. (ㄱ:HandlerAdapter 위임, ㄴ:HandlerMapping 조회, ㄷ:요청 수신, ㄹ:ViewResolver, ㅁ:Controller 실행, ㅂ:응답)",주관식,,,,,ㄷ -> ㄴ -> ㄱ -> ㅁ -> ㄹ -> ㅂ,,0,2025-11-21,2025-11-21,2025-11-21,"DispatcherServlet이 요청을 받고(ㄷ), 핸들러를 찾고(ㄴ), 어댑터를 통해(ㄱ) 컨트롤러를 실행(ㅁ)한 뒤, 뷰 리졸버(ㄹ)를 거쳐 응답(ㅂ)합니다.",,Spring
HandlerInterceptor의 3가지 핵심 메서드 이름을 실행 시점(전/후/완료) 순서대로 적으시오.,주관식,,,,,"preHandle, postHandle, afterCompletion",,0,2025-11-21,2025-11-21,2025-11-21,"컨트롤러 호출 전: preHandle, 호출 후: postHandle, 모든 작업 완료 후: afterCompletion",,Spring
"WebMvcConfigurer에서 인터셉터를 등록할 때, 특정 경로(예: /login)를 제외하기 위해 사용하는 메서드 이름은?",주관식,,,,,excludePathPatterns,,0,2025-11-21,2025-11-21,2025-11-21,registry.addInterceptor(...).addPathPatterns(...)로 적용 경로를 설정하고 .excludePathPatterns(...)로 제외 경로를 설정합니다.,,Spring
Q. REST API 설계 규칙으로 올바른 것을 고르시오,객관식,슬래시 구분자(/ )는 계층 관계를 나타내는데 사용하고 주로 마지막 문자로 포함한다.,하이픈(- )은 URI에 사용하지 않는다.,URI 경로에는 대문자가 적합하다.,파일확장자는 URI에 포함하지 않는다.,파일확장자는 URI에 포함하지 않는다.,,0,2025-11-21,2025-11-21,2025-11-21,,,REST api
REST의 URL 작성 시 정보의 자원을 표현하는 방식으로 올바르지 않은 것은?,객관식,"resource는 동사보다는 명사를, 대문자보다는 소문자를 사용한다.",resource의 도큐먼트 이름으로는 복수 명사를 사용해야 한다.,resource의 컬렉션 이름으로는 복수 명사를 사용해야 한다.,resource의 스토어 이름으로는 단수명사를 사용해야 한다.,resource의 도큐먼트 이름으로는 복수 명사를 사용해야 한다.,,0,2025-11-21,2025-11-21,2025-11-21,,,REST api
REST API의 주요 특징으로 올바르지 않은 것은?,객관식,자원 중심(resource-oriented) : 모든 것은 자원으로 표현되면 각 자원은 고유한 URI를 가짐,HTTP 메서드 활용 : 요청을 위해 HTTP의 GET/POST/UPDATE/DELETE등을 사용함,무상태(Stateless) : 각 요청은 이전 요청과 독립적이며 서버는 클라이언트의 상태를 저장하지 않음,캐시 가능성(Cacheability): 클라이언트 또는 서버가 응답을 캐싱하여 재사용할 수 있도록 하여 성능을 향상시킴,HTTP 메서드 활용 : 요청을 위해 HTTP의 GET/POST/UPDATE/DELETE등을 사용함,,0,2025-11-21,2025-11-21,2025-11-21,,,REST api
다음 중 Spring의 @Configuration 클래스와 프록시(Proxy)에 대한 설명으로 가장 적절하지 않은 것(틀린 것)을 고르시오.,객관식,"AOP 프록시: @Configuration 클래스에 적용된 프록시는 AopUtils.isAopProxy() 메서드로 확인 시 true를 반환하며, 이는 일반적인 AOP(예: 로깅) 적용을 의미합니다.","@EnableAsync: 이 애너테이션이 @Configuration에 추가되면, @Async가 붙은 빈(Bean)들은 AOP 프록시로 동작하게 됩니다.","@EnableCaching: 이 애너테이션이 @Configuration에 추가되면, @Cacheable이 붙은 빈(Bean)들은 캐시 로직을 처리하는 AOP 프록시로 동작하게 됩니다.","싱글톤 보장: Spring은 @Configuration 클래스를 CGLIB 프록시로 만들어, @Bean 메서드가 여러 번 호출되어도 항상 동일한(싱글톤) 빈 인스턴스를 반환하도록 보장합니다.","AOP 프록시: @Configuration 클래스에 적용된 프록시는 AopUtils.isAopProxy() 메서드로 확인 시 true를 반환하며, 이는 일반적인 AOP(예: 로깅) 적용을 의미합니다.",,0,2025-11-21,2025-11-21,2025-11-21,@Configuration의 프록시는 일반적인 AOP 목적(횡단 관심사 적용)과 다르기 때문에 AopUtils.isAopProxy()에서 false를 반환할 수 있습니다. 이는 싱글톤 보장이라는 특수 목적의 프록시입니다.,,Spring MVC
다음 중 Spring 애너테이션과 그 설명이 가장 적절하지 않은 것(틀린 것)을 고르시오.,객관식,"@Controller: 클래스에 적용되어 Spring이 해당 클래스를 컴포넌트 스캔 대상으로 인식하고, MVC의 'Handler' 역할을 하는 빈으로 등록합니다.","@RequestMapping: 클래스 레벨에 적용 시, 해당 클래스 내 모든 핸들러 메서드의 공통 URL 접두사(prefix)로 동작합니다.",@RequestParam: 클라이언트가 보낸 요청 파라미터(예: /echo?msg=hello)의 'msg' 값을 메서드 매개변수(String msg)에 바인딩합니다.,"Model (매개변수): 컨트롤러 메서드의 매개변수로 선언 시, 클라이언트가 보낸 JSON 데이터를 자동으로 객체에 바인딩하여 받습니다.","Model (매개변수): 컨트롤러 메서드의 매개변수로 선언 시, 클라이언트가 보낸 JSON 데이터를 자동으로 객체에 바인딩하여 받습니다.",,0,2025-11-21,2025-11-21,2025-11-21,이 설명은 'Model'이 아니라 '@RequestBody' 애너테이션이 붙은 객체 매개변수의 역할입니다. 'Model' 매개변수는 뷰에 데이터를 전달하기 위해 DispatcherServlet이 넣어주는 통입니다.,,Spring MVC
" Spring Boot에서 JSP를 View로 사용하기 위한 설정에 대한 설명 중, 올바르게 짝지어진 것을 고르시오.",객관식,"ViewResolver 설정 (properties): spring.mvc.view.prefix와 spring.mvc.view.suffix를 설정하여, 컨트롤러가 반환한 뷰 이름(String)을 물리적 파일 경로로 완성합니다.","spring-boot-starter-web: Spring MVC, 내장 Tomcat, JSON 처리를 포함하며, JSP 렌더링 엔진(Jasper)까지 기본으로 포함합니다.","/static/ 디렉토리: Spring Boot에서 JSP, Thymeleaf 등 동적 웹 리소스를 배치하는 기본 경로입니다.",tomcat-embed-jasper: JSP에서 JSTL(JSP Standard Tag Library)을 사용하기 위해(예: c:forEach) 반드시 추가해야 하는 의존성입니다.,"ViewResolver 설정 (properties): spring.mvc.view.prefix와 spring.mvc.view.suffix를 설정하여, 컨트롤러가 반환한 뷰 이름(String)을 물리적 파일 경로로 완성합니다.",,0,2025-11-21,2025-11-21,2025-11-21,application.properties를 통한 ViewResolver 설정(prefix + 뷰 이름 + suffix)의 역할을 정확하게 설명했습니다.,,Spring MVC
"Spring MVC의 다양한 응답(Response) 방식에 대한 설명 중, 올바르게 짝지어진 것을 고르시오.",객관식,"@ResponseBody: 메서드의 반환 값(주로 객체)을 ViewResolver가 아닌 MessageConverter가 처리하여, JSON 등의 형태로 응답 본문에 직접 씁니다.","Model (객체 반환): 메서드에서 Model 객체 자체를 반환하면, DispatcherServlet은 이를 JSON으로 변환하여 응답합니다.","""redirect:"" (접두사): ViewResolver를 거쳐 뷰를 렌더링하며, request scope가 유지된 채로 새로운 요청이 발생합니다.","forward (String 반환): 클라이언트의 URL이 변경되며, Model에 저장된 데이터를 request scope를 통해 View로 전달합니다.","@ResponseBody: 메서드의 반환 값(주로 객체)을 ViewResolver가 아닌 MessageConverter가 처리하여, JSON 등의 형태로 응답 본문에 직접 씁니다.",,0,2025-11-21,2025-11-21,2025-11-21,"REST API 응답 방식인 @ResponseBody의 동작 원리(ViewResolver X, MessageConverter O)를 정확하게 설명했습니다.",,Spring MVC
"Spring MVC의 @Controller 내부에서 사용되는 애너테이션과 객체에 대한 설명 중, 올바르게 짝지어진 것을 고르시오.",객관식,@RequestParam: HTTP 요청 본문(body)에 담긴 JSON 데이터를 자바 객체로 변환하여 매개변수에 바인딩합니다.,"Model: ViewResolver를 거치지 않고, 메서드의 반환 값을 JSON이나 XML로 변환하여 HTTP 응답 본문에 직접 쓰도록 지시합니다.","@RequestMapping: 클래스 레벨에만 적용 가능하며, 컨트롤러가 처리할 공통 URL 접두사(prefix)를 지정합니다.","@GetMapping: @RequestMapping(method = RequestMethod.GET)의 축약형으로, HTTP GET 요청을 처리하는 메서드에 사용됩니다.","@GetMapping: @RequestMapping(method = RequestMethod.GET)의 축약형으로, HTTP GET 요청을 처리하는 메서드에 사용됩니다.",,0,2025-11-21,2025-11-21,2025-11-21,@GetMapping의 정의와 용도를 정확하게 설명했습니다.,,Spring MVC
다음 Spring의 주요 애너테이션과 그 기능 설명이 올바르게 짝지어진 것을 고르시오.,객관식,"@Cacheable: @EnableCaching과 함께 사용되며, 동일한 파라미터로 메서드 호출 시 실제 로직을 실행하지 않고 캐시된 값을 반환합니다.","@Async: @EnableAsync와 함께 사용되며, 메서드가 항상 'new Thread()'를 통해 새로운 스레드에서 동작하도록 보장합니다.","@EnableAsync: @Configuration 클래스에 사용하여, 해당 클래스 내부의 @Bean 메서드들이 싱글톤을 유지하도록 CGLIB 프록시를 적용합니다.","@Configuration: 클래스에 적용되어, 해당 클래스가 AOP의 'Aspect'임을 Spring 컨테이너에 알립니다.","@Cacheable: @EnableCaching과 함께 사용되며, 동일한 파라미터로 메서드 호출 시 실제 로직을 실행하지 않고 캐시된 값을 반환합니다.",,0,2025-11-21,2025-11-21,2025-11-21,메서드의 실행 비용을 줄이기 위한 @Cacheable의 핵심 기능(캐시 조회 및 반환)을 정확하게 설명했습니다.,,Spring MVC
"다음 Spring MVC의 요청 처리 흐름에 대한 설명 중, 용어와 내용이 올바르게 짝지어진 것을 고르시오.",객관식,"Model: Handler가 View로 전달할 데이터를 저장하는 공간이며, 기본적으로 session scope에 저장됩니다.",View: DispatcherServlet으로부터 받은 뷰 이름(String)을 ViewResolver에게 전달하여 실제 뷰를 찾아달라고 요청합니다.,"Handler(@Controller): 비즈니스 로직(Service)을 호출하고, 그 결과를 Model에 저장한 뒤, DispatcherServlet에게 뷰의 논리적 이름을 반환합니다.","Service: Handler(@Controller)로부터 호출되어 실제 비즈니스 로직을 수행하며, HandlerMapping과 직접 통신합니다.","Handler(@Controller): 비즈니스 로직(Service)을 호출하고, 그 결과를 Model에 저장한 뒤, DispatcherServlet에게 뷰의 논리적 이름을 반환합니다.",,0,2025-11-21,2025-11-21,2025-11-21,"@Controller의 핵심 역할(1. 로직 호출, 2. 데이터 저장, 3. 뷰 이름 반환)을 정확하게 설명했습니다.",,Spring MVC
"Spring MVC의 핵심 구성 요소에 대한 설명 중, 용어와 역할이 올바르게 짝지어진 것을 고르시오.",객관식,"DispatcherServlet: HandlerMapping의 도움을 받아, URL에 매핑된 @Controller의 비즈니스 로직(Service)을 직접 실행합니다.",ViewResolver: 클라이언트의 모든 요청을 가장 먼저 받는 Front Controller입니다.,"HandlerAdapter: DispatcherServlet과 다양한 유형의 Handler(@Controller 등) 사이의 어댑터 역할을 하며, 실제 Handler의 메서드를 찾아 호출합니다.",HandlerMapping: @Controller가 반환한 논리적 뷰 이름(String)을 실제 뷰 객체(JSP)로 변환합니다.,"HandlerAdapter: DispatcherServlet과 다양한 유형의 Handler(@Controller 등) 사이의 어댑터 역할을 하며, 실제 Handler의 메서드를 찾아 호출합니다.",,0,2025-11-21,2025-11-21,2025-11-21,"1. DispatcherServlet은 비즈니스 로직을 '직접' 실행하지 않고, 'HandlerAdapter'에게 실행을 '위임'합니다.

2. 'ViewResolver'의 역할입니다. 'HandlerMapping'은 요청 URL을 처리할 'Handler'를 찾는 역할을 합니다.

4. 'DispatcherServlet'의 역할입니다. 'ViewResolver'는 뷰 이름을 실제 뷰 객체로 찾아주는 역할을 합니다.






",,Spring MVC
"Spring MVC의 DispatcherServlet이 클라이언트로부터 요청(request)을 받은 후, 뷰(View)를 거쳐 응답(response)을 반환하기까지의 핵심 처리 흐름을 HandlerMapping, HandlerAdapter, Handler, ViewResolver 컴포넌트를 포함하여 서술하시오.",주관식,,,,,"DispatcherServlet이 요청을 받으면, HandlerMapping으로 Handler를 찾고 HandlerAdapter로 실행합니다. Handler는 로직 처리 후 Model에 데이터를 담고 뷰 이름을 반환합니다. DispatcherServlet은 이 뷰 이름을 ViewResolver에게 줘서 실제 View를 찾게 하고, View는 Model 데이터로 화면을 그려 최종 응답을 보냅니다.",,0,2025-11-21,2025-11-21,2025-11-21,,,Spring MVC
"컨트롤러에서 Model 객체에 addAttribute 메서드를 사용하여 데이터를 저장하면, 이 데이터는 어떤 스코프(scope)에 저장되어 뷰(View)로 전달되는가?",주관식,,,,,request scope,,0,2025-11-21,2025-11-21,2025-11-21,,,Spring MVC
"Spring MVC에서 클라이언트의 HTTP 요청을 실제로 처리하는 객체를 'Handler'라고 부르며, 프로그래머는 주로 어떤 애너테이션을 사용하여 Handler를 작성하는가?",주관식,,,,,@Controller,,0,2025-11-21,2025-11-21,2025-11-21,,,Spring MVC
Spring에서 (1) @Async 애너테이션을 사용하여 비동기 처리를 (2) @Cacheable 애너테이션을 사용하여 캐시 기능을 활성화하기 위해 @Configuration 클래스에 추가해야 하는 애너테이션은 무엇인가?,주관식,,,,,"@EnableAsync
@EnableCaching",,0,2025-11-21,2025-11-21,2025-11-21,,,AOP
"컨트롤러 메서드의 반환 값으로 뷰(JSP)를 통하지 않고, 객체(예: Map)를 JSON 데이터 형태로 클라이언트에게 직접 응답하고자 할 때 사용해야 하는 애너테이션은 무엇인가?",객관식,@RequestMapping,@Controller,@ResponseBody,"
redirect:",@ResponseBody,,0,2025-11-21,2025-11-21,2025-11-21,"이 애너테이션을 사용하면 ViewResolver를 거치지 않고, 메서드의 반환 값이 직접 응답 본문(response body)에 작성됩니다.",,Spring MVC
컨트롤러의 요청 처리 메서드에서 Model 객체의 주요 역할은 무엇인가?,객관식,비즈니스 로직을 직접 수행한다.,클라이언트의 요청 파라미터를 수집한다.,다음으로 이동할 View의 이름을 반환한다.,처리된 데이터를 View에 전달하기 위해 저장한다.,처리된 데이터를 View에 전달하기 위해 저장한다.,,0,2025-11-21,2025-11-21,2025-11-21,"Model 객체에 데이터를 저장(addAttribute)하면, 이 데이터는 request scope에 저장되어 View(JSP)에서 참조할 수 있습니다.",,Spring MVC
다음 중 @RequestMapping(method = RequestMethod.GET)과 정확히 동일한 기능을 하는 축약형 애너테이션은 무엇인가?,객관식,@GetMapping,@PostMapping,@RequestParam,@ResponseBody,@GetMapping,,0,2025-11-21,2025-11-21,2025-11-21,@GetMapping은 RequestMethod.GET의 축약형입니다.,,Spring MVC
" Spring MVC의 @Controller 클래스에 대한 설명으로 틀린 것은?",객관식,하나의 @Controller 클래스는 단 하나의 요청 처리 메서드만 가질 수 있다.,@Component 애너테이션을 포함하는 Stereo type 애너테이션이다.,클래스 레벨의 @RequestMapping은 메서드 레벨 경로의 접두사(prefix)로 사용된다.,MVC에서 클라이언트의 요청을 받아들이는 Handler의 한 종류이다.,하나의 @Controller 클래스는 단 하나의 요청 처리 메서드만 가질 수 있다.,,0,2025-11-21,2025-11-21,2025-11-21,하나의 @Controller 클래스는 @RequestMapping을 통해 여러 개의 요청 처리 메서드를 포함할 수 있습니다.,,Spring MVC
"application.properties 파일에 spring.mvc.view.prefix=/WEB-INF/views/ 와 spring.mvc.view.suffix=.jsp 가 설정되어 있을 때, @Controller가 ""simple""이라는 문자열을 반환하면 ViewResolver가 최종적으로 찾는 경로는 무엇인가?",객관식,"
""/WEB-INF/views/simple""","""/WEB-INF/views/simple.jsp""","""/WEB-INF/simple/views.jsp""","""simple.jsp""","""/WEB-INF/views/simple.jsp""",,0,2025-11-21,2025-11-21,2025-11-21,ViewResolver는 반환된 뷰 이름(simple)에 prefix와 suffix를 조합하여 실제 뷰 경로를 완성합니다.,,Spring MVC
Spring Boot에서 JSP를 View로 사용하기 위해 pom.xml에 반드시 추가해야 하는 의존성은 무엇인가?,객관식,spring-boot-starter-json,spring-boot-starter-web,tomcat-embed-jasper,jakarta.servlet.jsp.jstl-api,tomcat-embed-jasper,,0,2025-11-21,2025-11-21,2025-11-21,"Spring Boot는 내장 Tomcat을 사용하며, 'jasper'는 JSP 파일을 서블릿 코드로 변환하는 엔진입니다. 따라서 이 의존성이 필요합니다.",,Spring MVC
"Spring MVC의 요청 처리 흐름 중, DispatcherServlet이 HandlerMapping으로부터 Handler를 찾은 후, 실제 Handler를 호출하기 위해 사용하는 구성 요소는 무엇인가?",객관식,HandlerAdapter,Model,ViewResolver,Service,HandlerAdapter,,0,2025-11-21,2025-11-21,2025-11-21,HandlerAdapter는 DispatcherServlet과 다양한 유형의 Handler 사이를 연결하며 실제 Handler의 실행을 담당합니다.,,Spring MVC
" Spring MVC에서 클라이언트의 모든 요청을 가장 먼저 받아 처리하며 'Front Controller Pattern'이 적용된 핵심 구성 요소는 무엇인가?",객관식,HandlerMapping,DispatcherServlet,HandlerAdapter,ViewResolver,DispatcherServlet,,0,2025-11-21,2025-11-21,2025-11-21,"DispatcherServlet은 Spring MVC의 중추적인 역할로, 모든 요청을 받아 적절한 핸들러에게 위임합니다.",,Spring MVC
Spring AOP의 한계점에 대한 설명으로 가장 올바른 것은?,객관식,클래스 내부의 다른 메서드를 호출할 때는 프록시를 통하지 않으므로 AOP가 적용되지 않는다.,@Async 애너테이션과는 함께 사용할 수 없다.,AOP는 private 메서드에만 적용이 가능하다.,AOP를 적용하면 원본 객체의 싱글톤(singleton)이 보장되지 않는다.,클래스 내부의 다른 메서드를 호출할 때는 프록시를 통하지 않으므로 AOP가 적용되지 않는다.,,0,2025-11-21,2025-11-21,2025-11-21,"Spring AOP는 프록시 기반으로 동작하며, 내부 메서드 호출(self-invocation)은 프록시를 거치지 않기 때문에 Advice가 동작하지 않습니다.",,AOP
"스프링 AOP에서 메소드 실행 이후 시점에 동작하는 Advice 유형은 크게 세 가지가 있습니다.  @After, @AfterReturning, @AfterThrowing  이 세 가지 Advice 애노테이션이 실행되는 조건(시점)과 주요 특징(차이점)을  ""예외 발생 여부"" 및 ""반환 값 접근"" 키워드를 중심으로 비교하여 서술하시오.",주관식,,,,,"@After (Finally):
  실행 조건: 대상 메소드의 실행이 예외를 발생시키는지 여부와 관계없이 항상 실행됩니다. (try-catch-finally 구문의 finally 블록과 유사합니다.)
  특징: 메소드가 정상 종료되었는지, 예외로 종료되었는지 알 수 없으며, 대상 메소드의 반환 값에 접근할 수 없습니다.

@AfterReturning (Success):
  실행 조건: 대상 메소드가 예외 없이 정상적으로 실행되어 반환(return)되었을 때만 실행됩니다.
  특징: returning 속성을 통해 대상 메소드의 반환 값에 접근하여 참조하거나 추가 로직을 수행할 수 있습니다. 예외가 발생하면 이 Advice는 실행되지 않습니다.

@AfterThrowing (Failure):
  실행 조건: 대상 메소드 실행 중 예외가 발생했을 때만 실행됩니다.
  특징: throwing 속성을 통해 발생한 예외 객체에 접근할 수 있습니다. 대상 메소드가 정상 종료되면 이 Advice는 실행되지 않습니다.",,0,2025-11-21,2025-11-21,2025-11-21,,,#AOP
"스프링 AOP에서 execution 지시자를 사용하여 Pointcut을 정의할 때, 다음 표현식이 의미하는 바를 서술하시오.",주관식,,,,,이 Pointcut 표현식은 com.example.service 패키지 및 그 **모든 하위 패키지( .. )**에 속한 **모든 타입(클래스/인터페이스)**의 **모든 메소드( * )**를 대상으로 합니다.,/images/id-sl83wy47m.png,0,2025-11-21,2025-11-21,2025-11-21,"차례대로 

- *: 모든 반환 타입을 의미합니다.

- com.example.service..: com.example.service 패키지와 그 모든 하위 패키지를 의미합니다.

- *: 패키지 내의 모든 클래스/인터페이스 이름을 의미합니다.

- *(..): 모든 이름의 메소드를 의미하며, (..)는 0개 이상의 모든 파라미터 타입을 의미합니다. (즉, com.example.service 패키지 및 하위 패키지의 모든 메소드 실행에 Advice를 적용하겠다는 의미입니다.)",,#AOP
"AOP의 Advice 유형 중, 대상 메소드의 실행을 직접 제어할 수 있으며(예: 실행 중단, 반환 값 변경), 메소드 실행 전후로 로직을 수행할 수 있는 가장 강력한 Advice 유형은 무엇인가?",객관식,@Before,@AfterReturning,@AfterThrowing,@Around,@Around,,0,2025-11-21,2025-11-21,2025-11-21,"@Around Advice는 ProceedingJoinPoint 객체를 매개변수로 받아, proceed() 메소드를 통해 대상 메소드의 실행 시점을 직접 제어할 수 있습니다. proceed() 호출 전후로 로직을 추가할 수 있으며, proceed()를 호출하지 않으면 대상 메소드가 실행되지 않게 하거나, 반환 값을 가로채 변경하는 것도 가능합니다. 반면 @Before, @AfterReturning, @AfterThrowing은 대상 메소드의 실행 전, 성공적 반환 후, 예외 발생 시에만 동작하며 실행 자체를 제어하지는 못합니다.",,#AOP
다음 중 스프링 AOP의 핵심 용어에 대한 설명으로 가장 옳지 않은 것은?,객관식,"Aspect: 공통 관심 사항(Cross-cutting concern)을 모듈화한 단위로, 여러 개의 Advice와 Pointcut의 조합으로 구성된다.","Join Point: Advice가 적용될 수 있는 애플리케이션 실행의 모든 지점(예: 메소드 호출, 필드 접근)을 의미한다.",Pointcut: 수많은 Join Point 중에서 Advice가 실제로 적용될 지점을 선별하기 위한 정규 표현식 또는 조건식이다.,"Weaving: Pointcut에 의해 선별된 Join Point에 Advice 로직을 삽입하는 과정으로, 스프링은 주로 컴파일 시점에 이를 수행한다.","Weaving: Pointcut에 의해 선별된 Join Point에 Advice 로직을 삽입하는 과정으로, 스프링은 주로 컴파일 시점에 이를 수행한다.",,0,2025-11-21,2025-11-21,2025-11-21,"Weaving에 대한 설명에서 스프링 AOP는 AspectJ와 달리 컴파일 시점(CTW)이나 로드 시점(LTW)이 아닌, **런타임 시점(Runtime)**에 프록시 객체를 생성하여 Advice를 적용하는 방식(Runtime Weaving)을 기본 전략으로 사용합니다.",,#AOP
현대적인 스프링 부트 애플리케이션 개발에서는 객체의 불변성(Immutability) 확보를 위해 생성자 주입 방식을 권장한다. Lombok 라이브러리를 사용하여 final로 선언된 필수 필드에 대한 생성자를 자동으로 생성하고자 할 때 가장 적절한 어노테이션은?,객관식,@NoArgsConstructor,@AllArgsConstructor,@RequiredArgsConstructor,@Data,@RequiredArgsConstructor,,0,2025-11-21,2025-11-21,2025-11-21,해설: @RequiredArgsConstructor는 초기화되지 않은 final 필드나 @NonNull이 붙은 필드만을 파라미터로 받는 생성자를 자동으로 생성합니다. 이는 불필요한 필드까지 포함하는 @AllArgsConstructor보다 생성자 주입 패턴에 더욱 최적화되어 있습니다.,,
"스프링 프레임워크는 계층별 역할 명시를 위해 @Component의 특수화된 형태(Stereotype)를 제공한다. 다음 중 이러한 계층별 빈 등록을 위한 어노테이션이 아니라, 등록된 빈을 '주입'받기 위한 메커니즘에 해당하는 것은?",객관식,@Service,@Repository,@Autowired,@Controller,@Autowired,,0,2025-11-21,2025-11-21,2025-11-21,"해설: @Service(비즈니스 계층), @Repository(영속 계층), @Controller(프레젠테이션 계층)는 모두 컴포넌트 스캔의 대상이 되어 자동으로 빈으로 '등록'되는 역할을 합니다. 반면, @Autowired는 컨테이너에 이미 등록된 빈을 필요한 곳에 '주입'하는 역할을 수행합니다.",,
동일한 인터페이스를 구현한 빈(Bean)이 두 개 이상 등록되어 있어 @Autowired 만으로는 주입 대상이 모호한 상황이 발생했다. 이때 특정 빈을 명시적으로 지정하여 모호성을 해결하기 위해 병행하여 사용해야 할 어노테이션은?,객관식,@Qualifier,@Component,@Service,@Controller,@Qualifier,,0,2025-11-21,2025-11-21,2025-11-21,"해설: 의존성 주입 대상이 여러 개일 경우 스프링 컨테이너는 어떤 빈을 주입해야 할지 판단할 수 없어 오류가 발생합니다. 이때 @Qualifier(""빈이름"")을 함께 사용하여 주입할 빈을 구체적으로 한정지을 수 있습니다.",,
"자바 표준(JSR-250) 스펙을 따르며, 의존성 주입(DI) 시 타입(Type)이 아닌 빈의 '이름(Name)'을 우선적인 주입 기준으로 삼는 어노테이션은 무엇인가?",객관식,@Autowired,@Inject,@Resource,@RequiredArgsConstructor,@Resource,,0,2025-11-21,2025-11-21,2025-11-21,"해설: @Resource는 자바 표준 어노테이션으로, name 속성을 사용하여 특정 빈 이름으로 의존성을 주입받을 때 주로 사용됩니다. 반면 @Autowired(스프링 전용)와 @Inject(자바 표준)는 기본적으로 타입(Type)을 기준으로 주입 대상을 찾습니다.",,
"다수의 필드를 가진 복잡한 객체(예: Address 클래스)를 설계할 때, 전통적인 전체 인자 생성자(All-args constructor) 대신 빌더(Builder) 패턴을 도입함으로써 얻을 수 있는 가장 주된 소프트웨어 공학적 이점은 무엇인가?",객관식,컴파일 시점에 객체 생성 속도가 현저히 향상된다.,"인자의 순서에 구애받지 않으며, 코드의 가독성과 유지보수성이 증대된다.",객체 생성 시 모든 필드를 강제로 초기화하도록 제한할 수 있다.,별도의 라이브러리 의존성 없이 자바 언어 자체 기능만으로 구현이 가능하다.,"인자의 순서에 구애받지 않으며, 코드의 가독성과 유지보수성이 증대된다.",,0,2025-11-21,2025-11-21,2025-11-21,"해설: 빌더 패턴은 메서드 체이닝을 통해 각 필드를 명시적으로 지정할 수 있게 해줍니다. 이는 생성자 인자가 많을 때 발생할 수 있는 인자 순서 혼동을 방지하고, 클라이언트 코드의 가독성을 크게 높여 유지보수를 용이하게 합니다.",,
"application.properties 파일이 아래와 같고, SystemInfo 빈이 로드되었을 때, info.getDetails()의 출력 결과로 올바른 것은?",객관식,${system.name} | ${system.admin:admin} | v9.0,SSAFY | admin | v9.0,SSAFY | admin | v${version},SSAFY | null | v9.0,SSAFY | admin | v9.0,/images/id-ocd3ohj9b.png,0,2025-11-21,2025-11-21,2025-11-21,"1. ${...} : system.name은 프로퍼티 파일에서 ""SSAFY"" 값을 찾아 name 필드에 주입합니다.

2. ""..."" (리터럴): version 필드는 ${...} 구문이 없으므로 ""9.0"" 문자열 리터럴 자체가 주입됩니다.

3. ${... : default} : system.admin 프로퍼티는 파일에 존재하지 않습니다. 이때 콜론(:) 뒤에 정의된 ""admin""이 기본값으로 admin 필드에 주입됩니다. 따라서 getDetails()는 ""SSAFY | admin | v9.0""을 반환합니다.",,"@Value,프로퍼티 주입"
"스프링 빈(Bean)의 생명주기(Lifecycle)에서, 생성자 호출과 모든 의존성 주입이 완료된 **'직후'**에 특정 초기화 로직(예: 자원 연결, 캐시 예열)을 실행하고 싶을 때 사용하는 애너테이션은 무엇인가요?",객관식,@PostConstruct,@PreDestroy,"@Bean(initMethod = ""..."")",@Autowired,@PostConstruct,,0,2025-11-21,2025-11-21,2025-11-21,,,빈 생명주기
"여러분이 소스 코드를 수정할 수 없는 외부 라이브러리의 클래스(예: ExternalImageProcessor)를 스프링 빈으로 등록해야 할 때, 가장 적절한 DI 방식은 무엇인가요?",객관식,묵시적 DI: 해당 라이브러리 클래스에 직접 @Component를 추가한다.,"명시적 DI: @Configuration 클래스 내부에 @Bean 메서드를 만들고, 그 안에서 new ExternalImageProcessor()를 반환한다.",필드 주입: 사용할 클래스에서 @Autowired로 ExternalImageProcessor를 바로 주입받는다.,Setter 주입: @ComponentScan으로 해당 라이브러리를 스캔한다.,"명시적 DI: @Configuration 클래스 내부에 @Bean 메서드를 만들고, 그 안에서 new ExternalImageProcessor()를 반환한다.",,0,2025-11-21,2025-11-21,2025-11-21,"2번 해설: 묵시적 DI(@Component)는 우리가 소스 코드를 수정할 수 있을 때만 사용할 수 있습니다. 외부 라이브러리의 코드는 수정이 불가능하므로 @Component를 붙일 수 없습니다. 이때 명시적 DI를 사용합니다. 우리의 @Configuration 설정 파일에 @Bean이 붙은 메서드를 만들고, 그 메서드 내부에서 new ExternalImageProcessor()를 호출하여 객체를 생성한 뒤 반환하면, 스프링 컨테이너가 이 객체를 빈으로 관리해 줍니다.",,"명시적 DI,#외부 라이브러리,@Bean"
" 묵시적 DI 방식에서 '@Component' 애너테이션의 주된 역할로 올바른 것은 무엇인가요?",객관식,명시적 DI에서 '@Bean'을 대체하여 설정 클래스에 사용된다.,"'@ComponentScan'이 스캔할 빈 대상을 표시하며, 스테레오타입 애너테이션의 기본이 된다.",오직 '@Service'나 '@Repository' 내부에서만 사용 가능하다.,이 애너테이션을 붙이면 즉시 싱글턴 빈(Bean)이 생성된다.,"'@ComponentScan'이 스캔할 빈 대상을 표시하며, 스테레오타입 애너테이션의 기본이 된다.",,0,2025-11-21,2025-11-21,2025-11-21,"@Component는 ""이 클래스는 빈이 될 수 있다""는 의도만 나타낼 뿐, 실제로 빈을 만들지는 않습니다. **@ComponentScan**이 이 애너테이션이 붙은 클래스들을 스캔해야 비로소 빈으로 등록됩니다. 또한 @Service, @Repository 등 다른 모든 스테레오타입 애너테이션의 내부에 포함되는 기본 애너테이션입니다.",,묵시적 DI
Spring에서 필드 주입(@Autowired 필드에 직접 사용)보다 생성자 주입을 권장하는 이유로 가장 적절한 것은 무엇인가요?,객관식,코드가 더 간결해지고 시각적으로 보기 좋기 때문이다.,필드 주입은 'private' 필드에는 사용할 수 없기 때문이다.,"final 키워드를 사용하여 의존성의 '불변성'을 보장하고, 테스트 코드 작성이 용이하기 때문이다.",생성자 주입만이 유일하게 순환 참조(Circular Dependency)를 해결할 수 있기 때문이다.,"final 키워드를 사용하여 의존성의 '불변성'을 보장하고, 테스트 코드 작성이 용이하기 때문이다.",,0,2025-11-21,2025-11-21,2025-11-21,"생성자 주입의 가장 큰 장점은, 주입받는 필드를 final로 선언하여 불변성을 확보할 수 있다는 점입니다. 또한, 순수 Java로 테스트 코드를 작성할 때 Mock 객체를 주입하기 매우 용이합니다.


1번은 오히려 필드 주입이 더 간결해 보입니다.

2번은 틀렸습니다. 필드 주입도 private 필드에 잘 동작합니다.

4번은 틀렸습니다. 생성자 주입은 순환 참조를 '해결'하는 것이 아니라, 빈 생성 시점에 오류를 발생시켜 즉시 발견하게 해줍니다.",,DI 주입 방식
Given-When-Then 패턴에서 각각이 무엇을 뜻하는지 쓰시오,주관식,,,,,"Given : 테스트를 위한 필요한 상황 준비
When : 테스트 하는 메서드 실행
Then : 테스트 결과 검증 ",,0,2025-11-21,2025-11-21,2025-11-21,,,Junit
테스트 원칙에 대한 설명으로 옳지 않은 것은?,객관식,여러번 반복해서 테스트를 진행하더라도 동일하게 동작해야 한다,@SpringBootTest는 슬라이스 테스트로 단위 테스트에 사용하기 적합하다,어떤 순서로 테스트를 하더라도 언제나 테스트는 성공해야 한다,테스트 자체 만으로 검증이 완료되어야 한다,슬라이스 테스트는 @WebMvcTest(컨트롤러) @DataJpaTest(리포지토리)처럼 특정 레이어만 잘라서 테스트하는 걸 말함.,,0,2025-11-21,2025-11-21,2025-11-21,,,JUnit
다음 코드 실행 결과로 콘솔에 출력되는 로그 레벨을 쓰시오,주관식,,,,,"INFO,WARN,ERROR",/images/id-1qn73txa2.png,0,2025-11-21,2025-11-21,2025-11-21,,"<root level=""INFO"">로 설정하면: INFO, WARN, ERROR가 출력",Logging
JUnit 테스트 코드에 대한 설명으로 틀린 것은?,객관식,@BeforeEach 는 각 테스트 실행 전마다 실행된다,@AfterAll은 클래스 내 모든 테스트가 끝난 뒤 한 번 실행된다,assertThrows()는 특정 메서드가 예외를 던지는지 검사한다,"assertEquals() 첫번째 인자는 실제값, 두번째 인자는 기대값이다 ","assertEquals() 첫번째 인자는 기대값, 두번째 인자는 실제값이다 ",,0,2025-11-21,2025-11-21,2025-11-21,,,JUnit
다음 중 Logback의 logback.xml 설정에 대한 설명으로 옳지 않은 것은?,객관식,<appender>는 로그를 어디로 보낼지 정의한다,<encoder>는 로그 메세지의 형식을 지정한다,"<root level=""INFO"">는 INFO이하의 로그를 모두 출력한다",<rollingPolicy>는 롤링 정책을 지정한다,"<root level=""INFO"">는 INFO이하의 로그를 모두 출력한다",,0,2025-11-21,2025-11-21,2025-11-21,,,Logging
Filter와 Interceptor의 차이로 옳은 것은?,객관식,Filter는 HTTP 요청 수준에서 Spring과 무관하게 동작한다.,Filter는 Spring 내부에서만 동작하고 Interceptor는 Servlet 단계에서 동작한다.,"Interceptor는 ServletRequest, ServletResponse만 접근 가능하다.",Filter는 Controller의 리턴값(ModelAndView)에도 접근할 수 있다.,Filter는 HTTP 요청 수준에서 Spring과 무관하게 동작한다.,,0,2025-11-21,2025-11-21,2025-11-21,,,Filter
Filter에서 자주 사용하는 기능으로 적절하지 않은 것은?,객관식,인코딩 설정,요청 로깅(logging),인증/인가 체크,비즈니스 로직 실행 및 DB CRUD 수행,비즈니스 로직 실행 및 DB CRUD 수행,,0,2025-11-21,2025-11-21,2025-11-21,,,Filter
Filter가 실행되는 시점으로 옳은 것은?,객관식,WAS(Tomcat) → Filter → DispatcherServlet 순서로 실행된다.,DispatcherServlet 이후 Controller 호출 직전에 실행된다.,Controller 실행 후 ModelAndView가 반환된 뒤에 실행된다.,Interceptor보다 뒤에서 실행된다.,WAS(Tomcat) → Filter → DispatcherServlet 순서로 실행된다.,,0,2025-11-21,2025-11-21,2025-11-21,,,Filter
Filter의 특징으로 옳지 않은 것은?,객관식,Spring Bean으로 자동 등록되며 DI 기능을 기본적으로 지원한다.,DispatcherServlet보다 먼저 실행된다.,요청/응답을 가로채 전·후 처리가 가능하다.,ServletRequest와 ServletResponse 기반으로 동작한다.,Spring Bean으로 자동 등록되며 DI 기능을 기본적으로 지원한다.,,0,2025-11-21,2025-11-21,2025-11-21,,,Filter
ANT 경로 패턴 설명으로 옳은 것은?,객관식,? 는 0개 이상의 글자를 의미한다.,* 는 정확히 한 글자를 의미한다.,** 는 0개 이상의 디렉토리를 의미한다.,ANT 패턴은 Interceptor에서만 사용 가능하며 다른 MVC 설정에는 사용할 수 없다.,** 는 0개 이상의 디렉토리를 의미한다.,,0,2025-11-21,2025-11-21,2025-11-21,,,Interceptor
WebMvcConfigurer의 역할 설명으로 옳지 않은 것은?,객관식,Interceptor를 특정 경로에 적용하거나 제외하는 설정을 할 수 있다.,View controller를 등록하여 Controller 없이도 view-name을 반환하도록 할 수 있다.,Spring MVC 관련 설정을 override할 수 있는 다양한 default 메서드를 제공한다.,Spring MVC 동작과 무관한 세션 관리와 JDBC 연결을 담당한다.,Spring MVC 동작과 무관한 세션 관리와 JDBC 연결을 담당한다.,,0,2025-11-21,2025-11-21,2025-11-21,,,"Interceptor,filter"
다음 중 Servlet Filter와 HandlerInterceptor 비교 설명으로 옳은 것은?,객관식,"Filter는 ServletRequest/Response 기반으로 동작하고, Interceptor는 Spring MVC 구조 내부에서 동작한다.",Interceptor는 Bean 등록이 불가능하고 DI를 사용할 수 없다.,"Filter는 DispatcherServlet 이후에 동작하고, Interceptor는 그 이전에 동작한다.","Filter는 Spring 내부에서 실행되며, Interceptor는 Spring 외부에서 실행된다.","Filter는 ServletRequest/Response 기반으로 동작하고, Interceptor는 Spring MVC 구조 내부에서 동작한다.",,0,2025-11-21,2025-11-21,2025-11-21,,,Interceptor
여러 개의 HandlerInterceptor가 등록된 경우 실행 순서로 옳은 것은?,객관식,"모든 메서드(preHandle, postHandle, afterCompletion)가 등록된 순서로 호출된다.","preHandle과 postHandle은 등록된 순서로, afterCompletion은 역순으로 호출된다.","preHandle은 등록된 순서, postHandle과 afterCompletion은 역순으로 호출된다.",모든 메서드가 역순으로 호출된다.,"preHandle과 postHandle은 등록된 순서로, afterCompletion은 역순으로 호출된다.",,0,2025-11-21,2025-11-21,2025-11-21,,,Interceptor
Interceptor의 특징으로 옳지 않은 것은?,객관식,DispatcherServlet이 HandlerAdapter를 호출하기 전후로 동작한다.,Servlet Filter보다 더 먼저 실행된다.,Spring Bean으로 등록하여 DI 등의 기능을 활용할 수 있다.,"인증 확인, 요청 감사, 성능 측정 등 공통 기능을 구현할 수 있다.",Servlet Filter보다 더 먼저 실행된다.,,0,2025-11-21,2025-11-21,2025-11-21,,,Interceptor
다음 중 AOP를 적용하기에 가장 적절한 **'횡단 관심사'**의 예시가 아닌 것은?,객관식,메서드 실행 시간 측정 (성능 모니터링),데이터베이스 트랜잭션 관리,회원 가입 시 이메일 형식 검증 및 저장 로직,접근 제어 및 보안 (인가),회원 가입 시 이메일 형식 검증 및 저장 로직,,0,2025-11-21,2025-11-21,2025-11-21,"* 횡단 관심사: 여러 모듈에 공통적으로 등장하는 기능(로깅, 보안, 트랜잭션 등)입니다

핵심 관심사: 3번(이메일 검증 및 저장)은 회원 가입이라는 기능의 고유한 목적입니다. 이것은 AOP로 분리하는 게 아니라 Service 클래스에서 직접 구현해야 할 **비즈니스 로직(Core Concern)**입니다. AOP는 핵심 로직을 보조하는 역할이라는 점을 잊지 마세요!",,AOP 적용
다음 Pointcut 표현식 execution(* com.ssafy.service.*.*(..)) 에 대한 설명으로 올바른 것은?,객관식,"com.ssafy.service 패키지의 모든 클래스에 있는, 파라미터가 없는 모든 메서드",com.ssafy.service 패키지 및 하위 패키지의 모든 클래스의 모든 메서드,"com.ssafy.service 패키지에 있는 모든 클래스의, 모든 파라미터를 허용하는 모든 메서드",com.ssafy.service 패키지의 모든 void 리턴 타입을 가진 메서드,"com.ssafy.service 패키지에 있는 모든 클래스의, 모든 파라미터를 허용하는 모든 메서드",,0,2025-11-21,2025-11-21,2025-11-21,"*: 리턴 타입 (무관)

com.ssafy.service: 패키지명 (정확히 이 패키지)

.*: 클래스명 (모든 클래스)

.*: 메서드명 (모든 메서드)

(..): 파라미터 (개수, 타입 무관하게 모두 허용)

오답 체크: 2번이 되려면 service..* 처럼 점 두 개(..)를 써야 하위 패키지까지 포함됩니다.",,Pointcut
Spring AOP에서 지원하는 JoinPoint의 특징으로 올바른 것은 무엇인가요?,객관식,필드 값 변경 시점,메서드 실행 시점,생성자 호출 시점,객체 초기화 시점,메서드 실행 시점,,0,2025-11-21,2025-11-21,2025-11-21,"Spring AOP는 프록시(Proxy) 패턴을 기반으로 동작합니다. 프록시는 메서드 호출을 가로채는 방식이므로, 오직 메서드 실행(Method Execution) 시점만 JoinPoint로 지원합니다.

필드 값 변경이나 생성자 호출 등을 제어하려면 AspectJ 같은 더 강력한 AOP 프레임워크를 사용해야 합니다. 시험에 자주 나오는 함정입니다!",,AOP특징
AOP의 주요 용어 중 'Aspect'의 구성 요소로 올바르게 짝지어진 것은 무엇인가요?,객관식,Advice + JoinPoint,Advice + Pointcut,Target + Proxy,Pointcut + Weaving,Advice + Pointcut,,0,2025-11-21,2025-11-21,2025-11-21,"Aspect = Advice + Pointcut 공식을 꼭 외우세요!

Advice: ""무엇을 언제 할 것인가?"" (횡단 관심사 로직) .

Pointcut: ""어디에 적용할 것인가?"" (적용 대상 필터링) .

이 두 가지가 합쳐져야 하나의 완벽한 관심사 모듈(Aspect)이 됩니다. JoinPoint는 적용 가능한 모든 지점을 말하는 추상적인 개념입니다.",,AOP구조
" Spring AOP에서 핵심 비즈니스 로직을 포함하고 있는 객체로, AOP가 적용될 대상을 지칭하는 용어는 무엇인가요?",객관식,Weaving,Target,Proxy,Aspect,Target,,0,2025-11-21,2025-11-21,2025-11-21,"Target: 부가 기능(Advice)을 부여할 대상을 말합니다. 핵심 비즈니스 로직을 담고 있는 클래스(예: UserServiceImpl)가 여기에 해당합니다

1번 Weaving: Aspect를 Target에 적용해서 Proxy를 만드는 **과정(행위)**을 뜻합니다.
3번 Proxy: Client와 Target 사이에서 흐름을 제어하는 대리자 객체입니다. Spring AOP는 이 프록시를 통해 동작합니다.
4번 Aspect: 횡단 관심사를 모듈화한 것(껍데기)입니다. Advice + Pointcut으로 구성됩니다.",,AOP
MyBatis에서 Java 인터페이스(Mapper)와 XML 파일을 연결하여 SQL을 실행하는 과정에는 엄격한 규칙이 존재합니다. 다음 중 연결 및 실행 오류가 발생하는 원인으로 볼 수 없는 것은?,객관식,"Mapper XML 파일의 <mapper namespace=""...""> 속성 값이 연결하려는 Java Mapper 인터페이스의  패키지를 포함한 전체 경로(Fully Qualified Name)와 일치하지 않는 경우.","application.properties (또는 yml) 파일에서 mybatis.mapper-locations 속성을 설정하지 않아, Spring Boot가 XML 파일의 위치를 찾지 못하는 경우.","Mapper 인터페이스의 메서드 파라미터가 DTO 객체인데, XML 쿼리 내에서 #{변수명}으로 접근할 때 DTO에 해당 변수명에 대한 Getter 메서드가 없는 경우.","XML 파일 내에서 <resultMap>을 정의할 때 type 속성에 DTO 클래스의 전체 경로(패키지 포함)를 적지 않고 클래스 이름(Alias)만 적었지만, mybatis.type-aliases-package 설정이 되어 있는 경우.","XML 파일 내에서 <resultMap>을 정의할 때 type 속성에 DTO 클래스의 전체 경로(패키지 포함)를 적지 않고 클래스 이름(Alias)만 적었지만, mybatis.type-aliases-package 설정이 되어 있는 경우.",,0,2025-11-21,2025-11-21,2025-11-21,"4. type 속성에 클래스 이름만 적었더라도, application.properties 등에 mybatis.type-aliases-package가 올바르게 설정되어 있다면 MyBatis가 자동으로 해당 패키지를 스캔하여 Alias를 등록하므로 정상적으로 동작. 오류의 원인이 아님

2. Spring Boot가 XML 파일을 로딩하려면 mapper-locations 설정이 필수적(기본 위치가 아닐 경우)

3. MyBatis는 내부적으로 Reflection을 사용하거나 Getter를 호출하여 파라미터 값을 읽어옴.",,#mybatis
데이터베이스의 정규화된 테이블들을 객체 지향적인 Java 객체(DTO)로 매핑할 때 ResultMap이 사용됩니다. 1:N (One-to-Many) 관계인 Member(1)와 Address(N)를 매핑하는 상황에 대한 설명으로 틀린 것은?,객관식,<collection> 태그의 ofType 속성은 리스트에 담길 제네릭 타입(여기서는 Address)을 지정하는 데 사용된다.,"Member 객체 내에 List<Address> addresses 필드가 있다면, 이는 <collection> 태그를 사용하여 매핑해야 한다.","notNullColumn 속성을 지정하면, 해당 컬럼의 값이 NULL일 경우 Collection 객체(List) 자체를 NULL로 생성한다.","<resultMap>의 extends 속성을 사용하면, 기존에 정의된 다른 ResultMap의 매핑 규칙을 상속받아 재사용할 수 있어 코드 중복을 줄일 수 있다.","notNullColumn 속성을 지정하면, 해당 컬럼의 값이 NULL일 경우 Collection 객체(List) 자체를 NULL로 생성한다.",,0,2025-11-21,2025-11-21,2025-11-21,"3. notNullColumn 속성은 해당 컬럼의 값이 NULL일 때, List에 아이템을 추가하지 않는 것이지, List 객체 자체를 NULL로 만드는 것이 아님. 즉, 주소 정보가 없는 회원의 경우 addresses 리스트는 NULL이 아니라 비어 있는(Empty) 리스트가 되는 것이 일반적.

추가 지식
조인(Join) 쿼리를 사용할 경우, 두 테이블에 동일한 이름의 컬럼(예: reg_date)이 존재할 수 있으므로 columnPrefix 속성을 사용하거나 SQL 별칭(Alias)을 활용하여 충돌을 방지해야 한다.",,#mybatis
"MyBatis는 복잡한 조건절 처리를 위해 <trim>, <where>, <set> 등의 동적 SQL 태그를 제공합니다. 다음 중 각 태그의 동작 방식에 대한 설명으로 가장 적절하지 않은 것은?",객관식,"<foreach> 태그는 IN 절을 구성할 때 주로 사용되며, open, close, separator 속성을 통해 괄호와 구분자를 자동으로 처리할 수 있다.","<where> 태그는 하위 엘리먼트의 내용이 AND나 OR로 시작할 경우, 이를 자동으로 제거하여 올바른 SQL 문법을 만든다.","<set> 태그는 UPDATE 문에서 사용되며, 동적으로 나열된 칼럼 할당문의 맨 앞에 있는 콤마(,)를 자동으로 제거한다.","<trim> 태그를 사용하면 <where>와 <set>의 기능을 커스텀하게 구현할 수 있다. 예를 들어 <trim prefix=""WHERE"" prefixOverrides=""AND | OR"">는 <where>와 동일하게 동작한다.","<set> 태그는 UPDATE 문에서 사용되며, 동적으로 나열된 칼럼 할당문의 맨 앞에 있는 콤마(,)를 자동으로 제거한다.",,0,2025-11-21,2025-11-21,2025-11-21,"3. <set> 태그는 UPDATE 구문에서 사용되며, 칼럼들이 나열된 후 맨 뒤(Suffix)에 붙은 불필요한 콤마(,)를 제거하는 역할. 맨 앞의 콤마를 제거하는 것이 아님.

1. <foreach>는 컬렉션을 반복하여 쿼리를 생성하며, IN (val1, val2) 형태를 만들 때 open=""("", close="")"", separator="","" 속성이 필수적으로 사용

2. <where> 태그는 내용이 있을 때만 WHERE를 붙이고, 시작 부분의 AND/OR를 prefixOverrides 하여 문법 오류를 방지
",,#mybatis
MyBatis에서 SQL을 작성할 때 사용되는 표기법 #{}와 ${}의 차이는 보안과 성능 측면에서 결정적인 차이를 만듭니다. 다음 설명 중 기술적으로 올바르지 않은 것은 무엇인가요?,객관식,"#{}를 사용하면 내부적으로 JDBC의 PreparedStatement를 생성하며, 파라미터가 ?로 치환되어 바인딩된다.","${}는 문자열 치환(String Substitution) 방식으로 동작하므로, 테이블명이나 컬럼명과 같은 메타 데이터를 동적으로 변경해야 할 때 유용하다.","사용자 입력을 ${}로 받아 쿼리를 작성할 경우, SQL Injection 공격에 취약해지므로 검증되지 않은 사용자 입력에는 절대 사용해서는 안 된다.","#{}를 사용하면 전달된 파라미터에 따옴표(')가 자동으로 붙지 않아, 문자열 데이터를 처리할 때 개발자가 직접 따옴표를 추가해야 한다.","#{}를 사용하면 전달된 파라미터에 따옴표(')가 자동으로 붙지 않아, 문자열 데이터를 처리할 때 개발자가 직접 따옴표를 추가해야 한다.",,0,2025-11-21,2025-11-21,2025-11-21,"4. #{}는 JDBC의 PreparedStatement 파라미터 바인딩(?)을 사용. 이 방식은 데이터베이스 드라이버가 타입에 맞춰 필요한 따옴표 처리를 자동으로 수행. 따라서 개발자가 직접 따옴표를 붙일 필요가 없음. 오히려 따옴표를 붙이면 문법 에러가 발생

2. ${}는 JDBC의 Statement를 사용하여 쿼리 문자열 자체를 재구성. 따라서 값 바인딩으로는 불가능한 테이블명이나 컬럼명 변경(구조 변경)이 가능. 

3. ${}는 단순 문자열 치환이므로 악의적인 SQL 구문이 그대로 실행될 수 있음",,#mybatis
"Spring의 @Transactional 전파 속성 중, 호출되는 메서드가 이미 진행 중인 트랜잭션이 있으면 새로운 트랜잭션을 시작하고, 이전 트랜잭션은 일시 중지(Pending)시키는 속성은 무엇인까?",객관식,PROPAGATION_REQUIRED,PROPAGATION_SUPPORTS,PROPAGATION_NESTED,PROPAGATION_REQUIRES_NEW,PROPAGATION_REQUIRES_NEW,,0,2025-11-21,2025-11-21,2025-11-21,"PROPAGATION_REQUIRES_NEW는 항상 새로운 독립적인 트랜잭션을 시작합니다. 호출되는 시점에 기존 트랜잭션(T.X_A)이 있다면, 그 트랜잭션은 일시 중지(Pending)되고 새로운 트랜잭션(T.X_B)이 시작됩니다. 이 두 트랜잭션은 별개로 구성되어 한쪽에서 롤백이 발생해도 다른 쪽에 영향을 주지 않습니다.",,#mybatis
스프링에서 MyBatis 기반의 트랜잭션을 관리하기 위해 PlatformTransactionManager 인터페이스의 구현체 중 주로 사용되는 것은 무엇인가?,객관식,JtaTransactionManager,JpaTransactionManager,DataSourceTransactionManager,HibernateTransactionManager,DataSourceTransactionManager,,0,2025-11-21,2025-11-21,2025-11-21,"Spring의 PlatformTransactionManager는 DB 접근 기술과 무관한 트랜잭션 추상화 계층이며 , MyBatis와 같이 일반적인 JDBC 기반 기술을 사용할 때는 DataSourceTransactionManager 구현체가 사용됩니다. JpaTransactionManager는 JPA를 사용할 때 , JtaTransactionManager는 분산 트랜잭션 처리에 사용됩니다.",,#mybatis
Service Layer가 없을 때 Data Access Layer(DAO/Repository)에서 발생하는 트랜잭션 관리의 가장 큰 문제점은 무엇인가?,객관식,SQL 삽입 공격({} 사용)에 취약해져 보안 문제가 발생한다.,"단일 업무 단위(예: 계좌 이체)를 하나의 트랜잭션으로 묶기 어렵고, 각 쿼리(Connection) 단위로 트랜잭션이 분리되어 데이터 정합성을 보장하기 힘들다.","MyBatis의 동적 SQL 기능(if, where 등)을 사용할 수 없어 쿼리 작성이 복잡해진다.",JDBC API에 종속되지 않고 Spring의 DataAccessException으로만 예외가 발생한다.,"단일 업무 단위(예: 계좌 이체)를 하나의 트랜잭션으로 묶기 어렵고, 각 쿼리(Connection) 단위로 트랜잭션이 분리되어 데이터 정합성을 보장하기 힘들다.",,0,2025-11-21,2025-11-21,2025-11-21,"Service Layer가 없을 때, Data Access Layer(Repository)는 일반적으로 단일 쿼리 단위로 데이터 저장소에 접근합니다. 이 경우, '계좌 이체'와 같이 여러 쿼리(예: A 출금, B 입금)가 하나의 업무 단위로 묶여 단일 트랜잭션(Unit of Work)으로 처리되어야 하지만, 각 쿼리가 별도의 Connection에서 처리되면 커밋/롤백이 분리되어 데이터 일관성/정합성 문제가 발생합니다. Service Layer는 Connection 관리 책임을 통해 이 문제를 해결합니다.",,#mybatis
Spring 환경에서 @Transactional의 역할 및 기본 동작 방식으로 옳은 것은?,객관식,"JDBC API를 직접 호출하여 트랜잭션의 시작, 커밋, 롤백을 수동으로 코딩해야 한다.","AOP 기반의 프록시를 생성하여 메서드 호출 이전에 트랜잭션을 시작하고, 정상 종료 시 커밋, RuntimeException 발생 시 롤백을 자동으로 처리한다.",트랜잭션 경계를 설정하고 DataAccessException이 발생하면 자동으로 SQLException으로 변환하여 전파한다.,트랜잭션 처리를 위해 반드시 PlatformTransactionManager의 구체적인 구현체를 직접 주입받아 호출해야 한다.,"AOP 기반의 프록시를 생성하여 메서드 호출 이전에 트랜잭션을 시작하고, 정상 종료 시 커밋, RuntimeException 발생 시 롤백을 자동으로 처리한다.",,0,2025-11-21,2025-11-21,2025-11-21,Spring의 @Transactional은 AOP(Aspect-Oriented Programming)를 통해 **프록시(Proxy)**를 생성하여 선언적 트랜잭션 처리를 제공합니다.,,#mybatis
"Book 클래스가 Publisher 객체를 1:1로 가질 때, 빈칸에 들어갈 태그는?",객관식,<collection>,<join>,<nested>,<association>,<association>,/images/id-bv2s7qhmy.png,0,2025-11-21,2025-11-21,2025-11-21,<association>: 1:1 / <collection>: 1:N,,#mybatis
빈칸에 들어갈 올바른 코드는?,객관식,${bookColumns},"<include refid=""bookColumns""/>","<sql ref=""bookColumns""/>",#{bookColumns},"<include refid=""bookColumns""/>",/images/id-fej6dq33d.png,0,2025-11-21,2025-11-21,2025-11-21,<sql> + <include>는 세트,,#mybatis
"List<String> isbns = Arrays.asList(""A"", ""B"", ""C""); 를 파라미터로 전달할 때, 빈칸에 들어갈 속성명을 순서대로 나열하시오.",주관식,"open, close, separator","separator, open, close","open, separator, close",,"open, separator, close",/images/id-i96171bv9.png,0,2025-11-21,2025-11-21,2025-11-21,,,#mybatis
DAO 구현체의 selectOne() 메서드를 MyBatis로 변환해보세요.,주관식,,,,,"<select id=""selectOne"" parameterType=""string"" resultType=""Book"">
        SELECT isbn, title, author, price 
        FROM book 
        WHERE isbn = #{isbn}
</select>",/images/id-wxmm3fq6m.png,0,2025-11-21,2025-11-21,2025-11-21,,,#mybatis
"MyBatis에서 DB 컬럼명 $\text{user_name}$과 DTO 필드명 $\text{userName}$이 불일치할 때, 매핑 규칙을 수동으로 명시하여 해결하기 위해 사용하는 태그와 해당 태그가 포함하는 자식 태그가 올바르게 짝지어진 것은 무엇입니까?",객관식,"태그: <select>, 자식: <id>, <result>","태그: <resultMap>, 자식: <id>, <result>","태그: <parameterMap>, 자식: <parameter>","태그: <sql>, 자식: <id>, <result>","태그: <resultMap>, 자식: <id>, <result>",,0,2025-11-21,2025-11-21,2025-11-21,"컬럼명과 필드명이 불일치하거나 JOIN 등으로 구조가 복잡할 때, $\text{}$을 사용하여 수동 매핑 규칙을 정의하며, 기본 키는 $\text{<id>}$, 일반 컬럼은 $\text{<result>}$ 태그를 사용합니다.",,#mybatis
MyBatis의 핵심 개념과 특징에 대한 설명으로 가장 적절하지 않은 것은 무엇입니까?,객관식,MyBatis는 ORM(Object-Relational Mapping) 기술을 사용하여 개발자가 SQL 없이 Java 객체만으로 DB 작업을 수행하도록 한다.,"MyBatis는 복잡한 JDBC 코드를 대신 처리해주는 영속성(Persistence) 프레임워크이다.

","PreparedStatement를 사용하기 위해 SQL 파라미터를 #{…} 문법으로 처리하여 SQL Injection 공격을 방어한다.

","SQL 쿼리를 자바 코드가 아닌 별도의 XML 파일에 분리하여 관리하는 특징을 가진다.

",MyBatis는 ORM(Object-Relational Mapping) 기술을 사용하여 개발자가 SQL 없이 Java 객체만으로 DB 작업을 수행하도록 한다.,,0,2025-11-21,2025-11-21,2025-11-21,"MyBatis는 SQL Mapper이며, SQL 작성을 개발자가 직접 해야 합니다. SQL 없이 객체만으로 작업하는 것은 JPA와 같은 완전한 ORM 프레임워크의 특징입니다.",,#mybatis
mybatis.type-aliases-package를 선언하는 파일의 이름은?,주관식,,,,,application.properties,,0,2025-11-21,2025-11-21,2025-11-21,application.properties에 dto의 경로를 설정하면 mapper xml파일의 parameterType 태그 속성에서 경로를 생략하고 사용할 수 있다.,,#mybatis
mybatis xml태그에 대한 설명으로 틀린 것은?,객관식,"<mapper namespace=""[dao의 경로]"">","<select id=""[resultmap재사용을 위한 식별자]"">","<select parameterType=""dao의 함수가 파라미터로 전달받은 객체의 타입"">","<result column=""스키마의 컬럼명"" property=""dto 필드명"">","<select id=""[resultmap재사용을 위한 식별자]"">",,0,2025-11-21,2025-11-21,2025-11-21,select의 id에는 dao의 함수명을 작성한다.,,#mybatis
Swagger(OpenAPI)를 사용하면 팀 프로젝트에서 어떤 장점이 있는지 서술하시오.,주관식,,,,,"API 명세가 자동으로 관리되어 문서와 실제 코드의 일관성이 있음
프론트와 백엔드 협업 시 API 요청 형식과 응답 형식을 명확하게 공유할 수 있음
별도의 API 명세 문서를 작성할 필요가 줄어들어 유지보수 효율이 올라감
API 테스트가 손쉽게 가능해 개발 속도 향상",,0,2025-11-21,2025-11-21,2025-11-21,,,REST API
Swagger에서 Request Body를 문서화할 때 사용하는 어노테이션은?,객관식,@Schema,@RestController," @Autowired",@Table,@Schema,,0,2025-11-21,2025-11-21,2025-11-21,,,REST API
"Swagger에서 @Operation(summary = ""..."")의 역할은 무엇인가?",객관식,API 요청을 자동으로 캐싱하는 역할,해당 API를 호출할 때 사용하는 기본 포트 지정,해당 API 설명(요약 문구) 제공,예외 발생 시 사용하는 Handler 등록,해당 API 설명(요약 문구) 제공,,0,2025-11-21,2025-11-21,2025-11-21,,,REST API
Swagger(OpenAPI)의 주요 목적은 무엇인가?,객관식,서버의 로그 레벨을 자동으로 조절하기 위함,API 문서를 자동 생성하고 테스트할 수 있도록 하기 위함,데이터베이스 스키마를 관리하기 위함,보안 키를 암호화하기 위함,API 문서를 자동 생성하고 테스트할 수 있도록 하기 위함,,0,2025-11-21,2025-11-21,2025-11-21,,,REST API
"URI를 구성할 때 단순 문자열(StringBuilder 등) 대신 UriComponentsBuilder를 사용했을 때의 장점으로, 제공된 내용에 명시된 것은 무엇입니까?",객관식,RestClient를 생성하려면 반드시 이것만 사용해야 한다.,별도의 객체 생성 없이 가장 빠르게 문자열을 연결할 수 있다.,오직 localhost 도메인 요청만 처리할 수 있다.,파라미터 바인딩({key})과 인코딩 처리가 용이하다.,파라미터 바인딩({key})과 인코딩 처리가 용이하다.,,0,2025-11-21,2025-11-21,2025-11-21,"{numOfRows}와 같이 템플릿 형태로 파라미터를 바인딩하고, .encode()를 통해 인코딩을 처리하는 기능을 보여줍니다.",,REST API
" 제공된 RestClient 사용 예제 코드에서 client.get()과 같은 HTTP 메서드 설정 직후에 호출되어, 실제 요청을 보내고 응답을 받아올 준비를 하는 메서드는 무엇입니까?",객관식,exchange(),build(),retrieve(),connect(),retrieve(),,0,2025-11-21,2025-11-21,2025-11-21,retrieve()는 요청을 수행하고 응답을 추출하기 위한 단계로 진입하는 메서드입니다.,,REST API
"웹 브라우저에서 Ajax 요청 시 'No 'Access-Control-Allow-Origin' header is present'와 같은 CORS(Cross-Origin Resource Sharing) 에러가 발생했습니다. 제공된 내용에 따를 때, 스프링 컨트롤러(Controller) 레벨에서 이를 해결하기 위해 사용할 수 있는 어노테이션은 무엇입니까?",객관식,@CrossOrigin,@RequestMapping,"
@RequestBody",@RestController,@CrossOrigin,,0,2025-11-21,2025-11-21,2025-11-21,@CrossOrigin 어노테이션은 클래스나 메서드에 적용하여 특정 출처(origin)에서의 리소스 공유를 허용하도록 설정합니다.,,REST API
스프링 팀(Spring Team)에서는 최근 Field Injection(@Autowired를 필드에 바로 사용)보다 Constructor Injection(생성자 주입)을 강력하게 권장합니다. 다음 중 생성자 주입을 권장하는 이유로 가장 적절하지 않은 것은?,객관식,필드에 final 키워드를 사용할 수 있어 객체의 불변성(Immutability)을 보장할 수 있다,의존 관계가 설정되지 않으면 객체 생성 단계에서 컴파일 타임(혹은 로딩 타임)에 오류를 발견할 수 있다.,"순환 참조(Circular Reference)가 발생할 경우, 어플리케이션 구동 시점에 에러를 뱉어 조기 발견이 가능하다.","코드가 가장 간결하며, 별도의 생성자 코드를 작성할 필요가 없어 생산성이 가장 높다.","코드가 가장 간결하며, 별도의 생성자 코드를 작성할 필요가 없어 생산성이 가장 높다.",,0,2025-11-21,2025-11-21,2025-11-21,"오답의 설명은 Field Injection의 장점입니다. 코드는 간결해지지만, 외부에서 의존성을 주입할 방법이 없어 테스트 코드 작성이 어렵고 프레임워크 의존적인 코드가 됩니다.",,스프링 & webmvc 요청처리 흐름
"Spring 실행 흐름에서 Filter와 Interceptor는 모두 공통 로직을 처리하지만 실행되는 '영역(Container)'이 다릅니다. Filter는 ( A ) Container에서 동작하고, Interceptor는 ( B ) Container 내부에서 동작합니다. A와 B에 들어갈 알맞은 말을 쓰시오.",주관식,,,,,"A: Servlet (또는 Web), B: Spring",,0,2025-11-21,2025-11-21,2025-11-21,"필터는 웹 어플리케이션(Tomcat)의 Context인 Servlet Container에서 관리되고, 인터셉터는 스프링 프레임워크의 Context인 Spring Container 안에서 관리됩니다. 이 차이로 인해 필터에서는 스프링 빈을 주입받을 때 추가 설정이 필요하거나 예외 처리가 다를 수 있습니다.",,스프링 & webmvc 요청처리 흐름
"Spring MVC의 핵심 컴포넌트로, 가장 앞단에서 모든 클라이언트의 요청을 받아 적절한 핸들러에게 위임하고, 그 결과를 뷰로 전달하는 '프론트 컨트롤러(Front Controller)' 패턴의 구현체 클래스 이름은 무엇인가?",주관식,,,,,DispatcherServlet,,0,2025-11-21,2025-11-21,2025-11-21,Spring Web MVC의 진입점이자 중앙 제어 담당 서블릿은 DispatcherServlet입니다.,,스프링 & webmvc 요청처리 흐름
"다음 중 Spring Container 내부가 아닌, 웹 어플리케이션 서버(WAS, 예: Tomcat)의 Servlet Container 영역에서 동작하며, 인코딩 변환이나 보안 관련 공통 작업을 주로 수행하는 구성 요소는?",객관식,Handler Adapter,Controller,Filter,Service,Filter,,0,2025-11-21,2025-11-21,2025-11-21,"Handler Adapter, Controller, Service는 모두 Spring Container(Application Context) 빈으로 관리되지만, Filter는 J2EE 표준 스펙으로 Web Application Server(Tomcat 등)의 Servlet Container 영역에서 동작합니다.",,스프링 & webmvc 요청처리 흐름
Spring Web MVC에서 클라이언트의 HTTP 요청이 들어와서 응답이 나갈 때까지의 일반적인 처리 순서로 올바른것은?,객관식,Filter -> DispatcherServlet -> Interceptor -> Controller,DispatcherServlet -> Filter -> Interceptor -> Controller,Filter -> Interceptor -> DispatcherServlet -> Controller,Interceptor -> DispatcherServlet -> Filter -> Controller,Filter -> DispatcherServlet -> Interceptor -> Controller,,0,2025-11-21,2025-11-21,2025-11-21,"요청은 가장 바깥쪽의 Filter(Web Context)를 거쳐 DispatcherServlet에 도달합니다. 이후 핸들러 매핑을 통해 컨트롤러가 결정되면, 실행 직전에 Interceptor(Spring Context)를 통과하여 최종적으로 Controller에 도달합니다.",,스프링 & webmvc 요청처리 흐름
"REST 서비스 작성 시 ResponseEntity 객체를 사용하는 이유는? ",주관식,,,,,"Rest형식의 서비스 결과를 Http 상태 코드와 함께 전송하기 위해 사용합니다 ",,0,2025-11-21,2025-11-21,2025-11-21,,,RESTAPI
"@ModelAttribute로 파라미터를 받았을때 Content-Type은? ",주관식,,,,,application/x-www-form-urlencoded,,0,2025-11-21,2025-11-21,2025-11-21,,,RESTAPI
"@Controller와 @ResponseBody를 합쳐서 쓰기 위한 REST API를 위한 annotation은? ",주관식,,,,,@RestController,,0,2025-11-21,2025-11-21,2025-11-21,,,RESTAPI
